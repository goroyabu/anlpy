#!/bin/sh
#/// @date 2020/04/03
#/// @author Goro Yabu

script_name="make_anlpy_project.sh"
script_version="1.0.0"

function usage ()
{
    echo "Usage: $script_name [options] ANL_MODULE_NAME.." 1>&2
    echo "Options:"
    echo "  -f                Force to overwrite existing files.  "
    echo "  -a                Output this user name as author.    "
    echo "  -p=<project>      Python package name to be exported. "
    echo "  -v                Print version and exit.             "
    echo "  -?                Print this message and exit.        "
    exit 1
}

function version ()
{
    echo ${script_version}
    exit 1
}

cmake_lists="CMakeLists.txt"
setup_py="setup.py"
uninstall_cmake="cmake_uninstall.cmake.in"
pyfunc_cpp="pyfunc.cpp"
run_py="run.py"

today=$(date "+%Y/%m/%d")
author=""

function gen_cmake_lists ()
{
    cpp_list=source/$1.cpp
    for module in ${@:2:($#-1)}
    do
	export cpp_list+=" "source/$module.cpp
    done
    
    projname=$VALUE_P
    
    cat <<EOF
# /// @file ${cmake_lists}
# /// @detail Automatically generated by ${script_name} ${script_version} 
# ----- PROJECT NAME & VERSION ----- #
project(${projname} CXX)
set(USER_ANL_LIB_NAME \${PROJECT_NAME}c)
set(MODULE_CXX_LIST ${cpp_list})

# ----- CMake & Compiler ----- #
cmake_minimum_required(VERSION 3.16)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_CXX_FLAGS "-std=c++1z -Wall")

# ----- Pybind11 ----- #
find_package(pybind11 REQUIRED)
set(PYBIND11_CPP_STANDARD "-std=c++1z")

# ----- ANLpy ----- #
find_package(bnk)
find_package(evs)
find_package(com_cli)
find_package(anl)

# ----- Build & Install ----- #
add_library(\${USER_ANL_LIB_NAME} STATIC \${MODULE_CXX_LIST})
target_link_libraries(\${USER_ANL_LIB_NAME} PRIVATE anl)

# ----- Build Python Package ----- #
pybind11_add_module(\${PROJECT_NAME} source/${pyfunc_cpp})
target_link_libraries(\${PROJECT_NAME} PRIVATE \${USER_ANL_LIB_NAME} anl)
install(TARGETS \${PROJECT_NAME} EXPORT \${PROJECT_NAME}-config DESTINATION lib)
install(EXPORT \${PROJECT_NAME}-config DESTINATION lib/\${PROJECT_NAME} EXPORT_LINK_INTERFACE_LIBRARIES)

# ----- Uninstallation ----- #
configure_file(cmake_uninstall.cmake.in cmake_uninstall.cmake IMMEDIATE @ONLY)
add_custom_target(uninstall COMMAND "\${CMAKE_COMMAND}" -P cmake_uninstall.cmake)

EOF

    return
}

function gen_setup_py ()
{
    projname=$1
    projver=$2
    
    cat <<EOF
#/// @file ${setup_py}
#/// @detail Automatically generated by ${script_name} ${script_version} 
import os
import re
import sys
import platform
import subprocess

from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext
from distutils.version import LooseVersion


class CMakeExtension(Extension):
    def __init__(self, name, sourcedir='.'):
        Extension.__init__(self, name, sources=[])
        self.sourcedir = os.path.abspath(sourcedir)


class CMakeBuild(build_ext):
    def run(self):
        try:
            out = subprocess.check_output(['cmake', '--version'])
        except OSError:
            raise RuntimeError("CMake must be installed to build the following extensions: " +
                               ", ".join(e.name for e in self.extensions))

        if platform.system() == "Windows":
            cmake_version = LooseVersion(re.search(r'version\s*([\d.]+)', out.decode()).group(1))
            if cmake_version < '3.1.0':
                raise RuntimeError("CMake >= 3.1.0 is required on Windows")

        for ext in self.extensions:
            self.build_extension(ext)

    def build_extension(self, ext):
        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))
        cmake_args = ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=' + extdir,
                      '-DPYTHON_EXECUTABLE=' + sys.executable]

        cfg = 'Debug' if self.debug else 'Release'
        build_args = ['--config', cfg]

        if platform.system() == "Windows":
            cmake_args += ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(cfg.upper(), extdir)]
            if sys.maxsize > 2**32:
                cmake_args += ['-A', 'x64']
            build_args += ['--', '/m']
        else:
            cmake_args += ['-DCMAKE_BUILD_TYPE=' + cfg]
            build_args += ['--', '-j2']

        env = os.environ.copy()
        env['CXXFLAGS'] = '{} -DVERSION_INFO=\\\"{}\\\"'.format(env.get('CXXFLAGS', ''),
                                                              self.distribution.get_version())
        if not os.path.exists(self.build_temp):
            os.makedirs(self.build_temp)
        #subprocess.check_call(['cmake', ext.sourcedir] + cmake_args, cwd=self.build_temp, env=env)
        subprocess.check_call(['cmake', '-G', 'Ninja', ext.sourcedir] + cmake_args, cwd=self.build_temp, env=env)
        subprocess.check_call(['cmake', '--build', '.'] + build_args, cwd=self.build_temp)
        subprocess.check_call(['cmake', '--install', '.'], cwd=self.build_temp)

setup(
    name='${projname}',
    version='${projver}',
    author='USER',
    author_email='',
    description='',
    long_description='',
    ext_modules=[CMakeExtension('${projname}')],
    cmdclass=dict(build_ext=CMakeBuild),
    zip_safe=False,
)

EOF
    return
}

function gen_uninstall_cmake ()
{
    cat <<EOF
#/// @file ${uninstall_cmake}
#/// @detail Automatically generated by ${script_name} ${script_version} 
IF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
  MESSAGE(FATAL_ERROR "Cannot find install manifest: \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\"")
ENDIF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")

FILE(READ "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt" files)
STRING(REGEX REPLACE "\n" ";" files "\${files}")

SET(NUM 0)
FOREACH(file \${files})
  IF(EXISTS "\$ENV{DESTDIR}\${file}")
    MESSAGE(STATUS "Looking for \"\$ENV{DESTDIR}\${file}\" - found")
    SET(UNINSTALL_CHECK_\${NUM} 1)
  ELSE(EXISTS "\$ENV{DESTDIR}\${file}")
    MESSAGE(STATUS "Looking for \"\$ENV{DESTDIR}\${file}\" - not found")
    SET(UNINSTALL_CHECK_\${NUM} 0)
  ENDIF(EXISTS "\$ENV{DESTDIR}\${file}")
  MATH(EXPR NUM "1 + \${NUM}")
ENDFOREACH(file)

SET(NUM 0)
FOREACH(file \${files})
  IF(\${UNINSTALL_CHECK_\${NUM}})
    MESSAGE(STATUS "Uninstalling \"\$ENV{DESTDIR}\${file}\"")
    EXEC_PROGRAM(
      "@CMAKE_COMMAND@" ARGS "-E remove \"\$ENV{DESTDIR}\${file}\""
      OUTPUT_VARIABLE rm_out
      RETURN_VALUE rm_retval
      )
    IF(NOT "\${rm_retval}" STREQUAL 0)
      MESSAGE(FATAL_ERROR "Problem when removing \"\$ENV{DESTDIR}\${file}\"")
    ENDIF(NOT "\${rm_retval}" STREQUAL 0)
  ENDIF(\${UNINSTALL_CHECK_\${NUM}})
  MATH(EXPR NUM "1 + \${NUM}")
ENDFOREACH(file)

FILE(REMOVE "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")

EOF
    return
}

function gen_module_header ()
{
    module=$1
    cat <<EOF
/**
   @file   ${module}.hpp
   @date   ${today}
   @author ${author}
   @detail Automatically generated by ${script_name} ${script_version}
**/

#ifndef ${module}_hpp
#define ${module}_hpp

#include <VANL_Module.hpp>

class ${module} : public anl::VANL_Module
{
public:
    ${module}();
    ~${module}();

    int mod_bgnrun() override;
    int mod_ana() override;
    int mod_endrun() override;
};

#endif

EOF
}

function gen_module_impl ()
{
    module=$1
    cat <<EOF
/**
   @file   ${module}.cpp
   @date   ${today}
   @author ${author}
   @detail Automatically generated by ${script_name} ${script_version}
**/

#include "${module}.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

${module}::${module}()
    : anl::VANL_Module("${module}", "0.1")
{
    /** Parameters can be modified via a method 'SetParameter' in Python **/
    // define_parameter<std::string>("input_file", "input.txt");
}
${module}::~${module}()
{
}

int ${module}::mod_bgnrun()
{
    /** This function is called at the begging of the run **/
    cout << mod_name2() << "::mod_bgnrun()";
    cout << " -> Hello! :D" << endl;

    /** Example of operations described here **/

    /** Opening files **/
    // std::string input_file = get_parameter<std::string>( "input.txt" );
    // ifs = std::ifstream( input_file );

    /** Definition of data buffers (BNK) **/
    // bnk::define<std::string>( "time_stamp" );
    // bnk::define<double>( "energy_deposit" );

    /** Definition of event flags (EVS) **/
    // evs::define( "multiple_signals_event" );

    return anl::ANL_OK;
}

int ${module}::mod_ana()
{
    /** This function is called at every events **/
    // cout << mod_name2() << "::mod_ana()" << endl;

    /** 1. Get values from data buffers (BNK) **/
    /**    Previous ANL modules often define buffers used here **/
    // int n_signals = bnk::define<int>( "n_signals" );
    // double energy_deposit = bnk::define<double>( "adc_value" ) * 0.25;

    /** 2. Use flags set by previous modules (EVS) **/
    // if ( evs::get("bad_signal_event") ) return ANL_SKIP;

    /** 3. Put values to data buffers (BNK) **/
    /**    This module often defines buffers used here **/
    // bnk::put<std::string>("time_stamp", "2020-04-03 21:12:15");
    // bnk::put<double>("energy_deposit", energy_deposit);

    /** 4. Set event flags in order for follwing modules to skip the same analysis **/
    // if ( n_signals > 1 || energy_deposit >= 5.0 ) evs::set( "multiple_signals_event" );

    return anl::ANL_OK;
}

int ${module}::mod_endrun()
{
    /** This function is called at the end of the run **/
    cout << mod_name2() << "::mod_endrun()";
    cout << " -> Good Bye. :)" << endl;

    /** Example of operations described here **/

    /** Closing files **/
    // ifs.close(); // std::ifstream

    return anl::ANL_OK;
}

EOF
}

function gen_python_wrapper ()
{
    cat <<EOF
/**
   @file   ${pyfunc_cpp}
   @date   ${today}
   @author ${author}
   @detail Automatically generated by ${script_name} ${script_version}
**/
EOF

    for module in $@
    do
	echo "#include \"$module.hpp\""
    done

    cat <<EOF

#include <pybind11/pybind11.h>

PYBIND11_MODULE(${VALUE_P}, m) {
    m.attr("__name__") = "${VALUE_P}";
    m.doc() = R"pbdoc(
        ${VALUE_P} Documentation
        -----------------------
    )pbdoc";

    pybind11::class_<anl::VANL_Module>(m, "VANL_Module", pybind11::module_local());

EOF
    for module in $@
    do
	cat <<EOF
    pybind11::class_<${module}, anl::VANL_Module>(m, "${module}")
	.def(pybind11::init<>())
	.def("SetParameter", &${module}::set_parameter<int>)
	.def("SetParameter", &${module}::set_parameter<double>)
	.def("SetParameter", &${module}::set_parameter<bool>)
	.def("SetParameter", &${module}::set_parameter<std::string>)
	.def("DefineParameter", &${module}::define_parameter<int>)
	.def("DefineParameter", &${module}::define_parameter<double>)
	.def("DefineParameter", &${module}::define_parameter<bool>)
	.def("DefineParameter", &${module}::define_parameter<std::string>)
	.def("ShowParameter", &${module}::show_parameters);

EOF
    done
	cat<<EOF
#ifdef VERSION_INFO
    m.attr("__version__") = VERSION_INFO;
#else
    m.attr("__version__") = "dev";
#endif
}
EOF

}

function gen_run_py ()
{
    projname=$VALUE_P
    
    cat <<EOF
#!/usr/local/bin/python3

import anlpy
import ${projname}

if __name__ == '__main__':
    anl = anlpy.ANLmanager()

EOF
    for module in $@
    do
	cat <<EOF
    tmp${module} = ${projname}.${module}()
    #temp${module}.SetParameter("copyid", "ss")
    anl.AddModule(tmp${module})

EOF
    done
    cat<<EOF
    anl.ShowAnalysis()
    anl.ReadData(10, 1)

    print("Test run of ${projname} is succeeded !")
EOF
}

function export_module ()
{
    module_name=$1

    header_name=${module_name}.hpp
    impl_name=${module_name}.cpp
    
    if [ $FLG_P = "TRUE" ]
    then
	header_name=${VALUE_P}/source/${module_name}.hpp
	impl_name=${VALUE_P}/source/${module_name}.cpp
    fi

    if [ -e $header_name -a $FLG_F = "FALSE" ];
    then
	echo "***Error*** : Remove the old file $header_name "
	exit
    fi
    
    if [ -e $impl_name -a $FLG_F = "FALSE" ];
    then
	echo "***Error*** : Remove the old file $impl_name "
	exit
    fi

    gen_module_header ${module_name} > ${header_name}
    gen_module_impl ${module_name} > ${impl_name}
}

function export_files ()
{
    module_list=$@

    # if [ $FLG_P = "FALSE" ]
    # then
    # 	exit	
    # fi
    # mkdir -p ${VALUE_P}
    
    for module in $module_list
    do
	export_module $module
    done    
}

function export_project ()
{
    module_list=$@
    project_name=$VALUE_P

    if [ -e $project_name -a $FLG_F = "FALSE" ];
    then
	echo "***Error*** : Remove the old directory $project_name "
	exit
    fi

    out_name=${VALUE_P}/source/${pyfunc_cpp}    
    if [ -e ${out_name} -a $FLG_F = "FALSE" ];
    then
	echo "***Error*** : Remove the old directory $project_name "
	exit
    fi
    
    mkdir -p ${project_name}
    mkdir -p ${project_name}/source
    mkdir -p ${project_name}/run

    gen_cmake_lists ${module_list} > ${project_name}/${cmake_lists}
    gen_setup_py ${project_name} "0.0.0" > ${project_name}/${setup_py}
    gen_uninstall_cmake > ${project_name}/${uninstall_cmake}

    gen_run_py ${module_list} > ${project_name}/run/${run_py}
    chmod +x ${project_name}/run/${run_py}

    gen_python_wrapper $module_list > ${out_name}    
}

FLG_A="FALSE"
FLG_F="FALSE"
FLG_P="FALSE"

while getopts fap:v OPT
do
    case $OPT in
	f ) FLG_F="TRUE"; ;;
	a ) FLG_A="TRUE"; ;;
	p ) FLG_P="TRUE"; VALUE_P="$OPTARG"; ;;#echo $VALUE_C ;;
	v ) version ;;
	\? ) usage ;;
	:) echo "Mission arg: -$OPTARG" >&2; usage ;;
	*) echo "Unknown option: -$OPTARG" >&2; usage ;;
    esac
done
shift $((OPTIND - 1))

if [ $# == 0 ]
then
    usage
fi

if [ $FLG_A = "TRUE" ]
then
    author=`whoami`
fi

if [ $FLG_P = "TRUE" ]
then
    export_project $@
fi

export_files $@
