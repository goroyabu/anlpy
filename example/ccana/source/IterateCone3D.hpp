/**
   @file   IterateCone3D.hpp
   @date   2020/05/12
   @author
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#ifndef IterateCone3D_hpp
#define IterateCone3D_hpp

#include <VANL_Module.hpp>

#include <iostream>
#include <thread>
#include <utility>
#include <vector>

#include <TFile.h>
#include <TTree.h>
#include <TH3F.h>
#include <TH2D.h>
#include <TH1D.h>

class IterateCone3D : public anl::VANL_Module
{

public:

    IterateCone3D();
    ~IterateCone3D();

    int mod_bgnrun() override;
    int mod_ana() override;
    int mod_endrun() override;

public:

    struct resptree_event
    {
	TTree * tree;
	long nentries;
	long current_entry;

	long first_entry;
	long last_entry;

	TH3F * response;
	resptree_event()
	    : tree(nullptr)
	{
	    response = new TH3F();
	    nentries = 0;
	    current_entry = -1;
	    set_entry_range(0,-1);
	}
	~resptree_event() {}

	long set_branch_address(TTree* tree)
	{
	    this->tree = tree;
	    tree->SetBranchAddress("response", &response);
	    nentries = tree->GetEntries();
	    if ( nentries>0 ) tree->GetEntry(0);
        set_entry_range( 0, -1 );
	    return nentries;
	}

	void set_entry_range(long first, long last)
	{
	    if ( last<0 || nentries<last ) last = nentries;
	    if ( 0<first ) first = 0;

	    if ( first < last ) {
		first_entry = first;
		last_entry = last;
		return;
	    }

	    first_entry = 0;
	    last_entry = nentries;
	}

	bool next()
	{
	    ++current_entry;

	    if ( current_entry>=last_entry ) return false;
	    // if ( current_entry>=nentries ) return false;
	    tree->GetEntry(current_entry);

	    if ( current_entry%100==0 ) {
		std::cout << current_entry << "/" << nentries << std::endl;
	    }

	    return true;
	}
	bool init_entry()
	{
	    //if ( nentries<=first ) first = 0;
	    current_entry = first_entry-1;
	    //if ( nentries>first ) tree->GetEntry(first);
	    tree->GetEntry(first_entry);
	    return true;
	}
    };

    class TH3Slicer
    {
    public:
	static std::vector<TH2D*> Slice(TH3F* th3);
    private:
	static TH2D* define_slice(TH3F* th3, int slice_axis=2);
    };

protected:

    TFile * input_file;
    TTree * input_tree;
    TFile * output_file;
    resptree_event event;
    TH3F * sbp_image;
    std::vector<TH3F*> mlem_image;
    std::vector<TH3F*> diff_image;

    std::vector<double> vector_integral_of_response;
    // std::vector<double> vector_integral_of_multiple;

    /* Parameters */
    int n_of_iterations;
    double denominator_offset;
    int eventid;
    int current_entry;
    bool is_enabled_multiple_thread;
    int n_threads;
    bool is_enabled_use_sbp_as_efficiency;

    /* Histogram */
    int nbins_xaxis, nbins_yaxis, nbins_zaxis;

    int index_of_2d_image;
    bool is_enabled_2d_reconstruction;

    /* Mutilple Thread */
    std::vector<std::pair<int,int>> list_of_xbin_ranges;

    TH1D * h1_integral_image_cross_response;
    TH1D * h1_integral_event_response;
    TH2D * h2_response_vs_image_cross_response;
    std::vector<TH3F*> list_of_images_cross_response;

    TH3F* next_image(TH3F* previous_image);

    using vector1 = std::vector<float>;
    using vector2 = std::vector<vector1>;
    using vector3 = std::vector<vector2>;

    vector3 make_vector3(int x, int y, int z, double value);

    void h2v_get_elements(TH3F* th3, vector3* out);
    void h2v_add_elements(TH3F* th3, vector3* out);

    void v2h_set_elements(const vector3& in, TH3F* th3);

    void v2v_add_elements(const vector3& in, vector3* out);
    void v2v_multiply_elements(const vector3& in, vector3* out);
    void v2v_divide_elements(const vector3& in, vector3* out);

    double get_integral(const vector3& in);
    void   scale_elements(double factor, vector3* out);

    // void multiply_elements(const vector3& in, vector3* out);
    // void copy_elements(const vector3& in, vector3* out);
    // void get_elements(TH3F* th3, vector3* out);
    // void add_elements(const vector3& in, TH3F* th3);

    static void h2v_get_elem_impl
    (TH3F* th3, vector3* out, int x1, int x2, int ny, int nz, bool is_2dimage=false, int index_of_z=-1);
    // static void v2v_multi_elem_impl
    // (const vector3& in, vector3* out, int x1, int x2, int ny, int nz);
    // static void v2v_add_elem_impl
    // (const vector3& in, vector3* out, int x1, int x2, int ny, int nz);

    // static void v2v_modify_element
    // (const vector3& in, vector3* out, int x1, int x2, int ny, int nz,
    //  std::function<void(const float, float*)> func);

};

#endif
