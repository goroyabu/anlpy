/***
    @file   ProjectComptree.hpp
    @date
    @author User
    @detail Automatically generated by mkanlproject
***/

#ifndef ProjectComptree_hpp
#define ProjectComptree_hpp

#include <tuple>

#include <TFile.h>
#include <TTree.h>
#include <TH2D.h>
#include <TH3F.h>
#include <TMath.h>
#include <TVector3.h>
#include <TF1.h>

#include <VANL_Module.hpp>

class ProjectComptree : public anl::VANL_Module
{
    public:
        ProjectComptree();
        ~ProjectComptree();

        int mod_bgnrun() override;
        int mod_ana() override;
        int mod_endrun() override;

    protected:

        // TFile * input_file;
        // TTree * input_tree;
        TFile * output_file;
        TTree * output_tree;
        TH3F * image;
        TH3F * image_etcc;
        TH1D * h1_cone_filling_ratio;
        TH1D * h1_arm_distribution;
        TH1D * h1_spd_distribution;
        TH2D * h2_arm_vs_spd;
        TH2D * h2_arm_distribition;
        TH2D * h2_spd_distribition;
        TH2D * h2_energy_hit1_vs_hit2;
        TH2D * h2_energy_hit1_vs_hit2_comp;
        TH1D * h1_totalenergy;
        TH1D * h1_totalenergy_comp;

        /** parameters */
        double cone_thick_rad;
        double arc_length_rad;
        double arc_length_sigma;
        double tangent_cone_thick;
        double distance_index_omega;
        double rotation_around_vertical_rad;
        bool enable_normalize_cone;
        bool is_used_polar_coordinate;
        bool is_used_tracking_failed_event;
        bool is_used_cut_by_track_feature;
        bool is_for_preselected_dataset;

        /* branch */
        /* inherited from eventtree */
        unsigned int ti;
        unsigned int livetime;
        unsigned int unixtime;
        unsigned int ext1pps;
        unsigned int msec_counter;

        /* new branches */
        int num_hits;
        unsigned int externalCLK;
        unsigned int first_internalCLK;
        short hit1_detector;
        float hit1_energy;
        float hit1_posx;
        float hit1_posy;
        float hit1_posz;
        short hit2_detector;
        float hit2_energy;
        float hit2_posx;
        float hit2_posy;
        float hit2_posz;
        float totalenergy;

        float theta_kine;
        float theta_geom;
        float theta_elec;
        float phi_esti;
        float phi_geom;

        float angle_inci;
        float de_over_dx;
        float prod_inci_phi;
        float sum_epi_around_init;
        float sum_epi_forward_init;

        float angle_electron_on_plane;
        float angle_electron_vertical;

        TH2D * etrack_calc_dedx;

    private :

        struct Hit
        {
            private :

                double x, y, z;
                double energy;
                double phi;

            public :
                Hit(double x, double y, double z, double energy, double phi)
                    : x(x), y(y), z(z), energy(energy), phi(phi)
                {}
                Hit(const Hit& other)
                    : x(other.x), y(other.y), z(other.z),
                    energy(other.energy), phi(other.phi)
                {}
                Hit& operator=(const Hit& other)
                {
                    x = other.x;
                    y = other.y;
                    z = other.z;
                    energy = other.energy;
                    phi = other.phi;
                    return *this;
                }
                TVector3 Postion() const
                {
                    return TVector3(x,y,z);
                }
                double Energy() const
                {
                    return energy;
                }
                double Phi() const
                {
                    return phi;
                }
        };

    private:

        int DefineBranch(TTree* tree);
        void CalcComptonEvent(const Hit& si, const Hit& cdte);
        bool Projection();//const Hit& si, const Hit& cdte);
        TH1D* GetFillingRatio
        (TH3F* image, const TVector3& scat, const TVector3& abso, double angle_theta_rad);
        double ScaleByFillingRatio(TH3F* th3, TH1D* ratio);

    public:
        inline static TVector3 VoxelCenter(TH3* h, int bin)
        {
            int xbin, ybin, zbin;
            h->GetBinXYZ( bin, xbin, ybin, zbin );
            auto x = h->GetXaxis()->GetBinCenter(xbin);
            auto y = h->GetYaxis()->GetBinCenter(ybin);
            auto z = h->GetZaxis()->GetBinCenter(zbin);
            return TVector3(x, y, z);
        }
        inline static TVector3 VoxelCenterPolar(TH3* h, int bin)
        {
            int xbin, ybin, zbin;
            h->GetBinXYZ( bin, xbin, ybin, zbin );
            auto x = h->GetXaxis()->GetBinCenter(xbin);
            auto y = h->GetYaxis()->GetBinCenter(ybin);
            auto radius = h->GetZaxis()->GetBinCenter(zbin);
            auto theta = TVector2::Phi_mpi_pi( TMath::Sqrt( x*x + y*y ) );
            auto x_in_3d = radius * TMath::Sin( theta ) * x / theta;
            auto y_in_3d = radius * TMath::Sin( theta ) * y / theta;
            auto z_in_3d = radius * TMath::Cos( theta );
            return TVector3( x_in_3d, y_in_3d, z_in_3d );
        }
        inline static double GetBinContent(TH1D* h, double x)
        {
            auto bin = h->GetXaxis()->FindBin(x);
            if ( 1 <= bin && bin <= h->GetXaxis()->GetNbins() )
            return h->GetBinContent(bin);
            return 0.0;
        }
        inline static bool IsVectorInside( TH3F* image, const TVector3& vec)
        {
            auto x = image->GetXaxis()->GetXmin() <= vec.X() &&
                vec.X() <= image->GetXaxis()->GetXmax();
            if ( x == false ) return false;

            auto y = image->GetYaxis()->GetXmin() <= vec.Y() &&
                vec.Y() <= image->GetYaxis()->GetXmax();
            if ( y == false ) return false;

            auto z = image->GetZaxis()->GetXmin() <= vec.Z() &&
                vec.Z() <= image->GetZaxis()->GetXmax();

            return z;
        }
};



#endif
