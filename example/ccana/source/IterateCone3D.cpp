/**
   @file   IterateCone3D.cpp
   @date   2020/05/12
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "IterateCone3D.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

IterateCone3D::IterateCone3D()
    : anl::VANL_Module("IterateCone3D", "0.1"),
      input_file(nullptr), input_tree(nullptr), output_file(nullptr), sbp_image(nullptr)
{
    /** Parameters can be modified via a method 'SetParameter' in Python **/
    // define_parameter<std::string>("input_file", "input.txt");
    define_parameter<std::string>("input_file", "input.root");
    define_parameter<std::string>("input_tree", "resptree");
    define_parameter<std::string>("output_file", "output.root");
    define_parameter<int>("n_of_iterations", 0);
    define_parameter<double>("denominator_offset", 10.0);
}
IterateCone3D::~IterateCone3D()
{
}

int IterateCone3D::mod_bgnrun()
{
    auto input_file_name = get_parameter<std::string>("input_file");
    input_file = new TFile( input_file_name.c_str() );
    if ( !input_file || input_file->IsZombie() ) {
	cout << "Opening " << input_file_name << " is failed." << endl;
	return anl::ANL_NG;
    }
    cout << input_file_name << " is opened." << endl;

    auto input_tree_name = get_parameter<std::string>("input_tree");
    input_tree = (TTree*)input_file->Get( input_tree_name.c_str() );
    if ( !input_tree ) {
	cout << input_tree_name << " is not found." << endl;
	return anl::ANL_NG;
    }

    auto nentries = event.set_branch_address(input_tree);
    if ( nentries==0 ) {
	cout << input_tree_name << " has NO event." << endl;
	return anl::ANL_NG;
    }
    cout << "# of entries in " << input_tree_name << " is " << nentries << endl;
    
    auto ofname = get_parameter<std::string>("output_file");
    output_file = new TFile( ofname.c_str(), "recreate" );
    if ( !output_file || output_file->IsZombie() ) {
        cout << "Creating " << ofname << " is failed." << endl;
        return anl::ANL_NG;
    }
    cout << ofname << " is created." << endl;

    sbp_image = (TH3F*)event.response->Clone();
    sbp_image->SetName("sbp_image");

    n_of_iterations = get_parameter<int>("n_of_iterations");

    denominator_offset = get_parameter<double>("denominator_offset");
    
    return anl::ANL_OK;
}

int IterateCone3D::mod_ana()
{
    // if ( !event.next() ) return anl::ANL_LOOP;
    // while ( event.next() ) {    
    // 	sbp_image->Add( event.response );
    // }

    if ( n_of_iterations == 0 ) {
	
	while ( event.next() ) 
	    sbp_image->Add( event.response );
	
	return anl::ANL_LOOP;
    }
    else {

	while ( event.next() ) {
	    sbp_image->Add( event.response );
	    auto integral = event.response->Integral();
	    vector_integral_of_response.emplace_back( integral );
	}

    }

    cout << "first backprojection is done" << endl;
    
    mlem_image.reserve( n_of_iterations );
    
    auto new_image = next_image( sbp_image );
    mlem_image.emplace_back( new_image );
    if ( n_of_iterations>1 ) 
	cout << "1/" << n_of_iterations << "iteration is done" << endl;    
    
    for ( int iteration=1; iteration<n_of_iterations; ++iteration ) {
	
	auto new_image = next_image( mlem_image[ iteration-1 ] );	
	mlem_image.emplace_back( new_image );

	cout << iteration+1 << "/" << n_of_iterations;
	cout << " iteration is done" << endl;	
    }    
    
    return anl::ANL_LOOP;
}

int IterateCone3D::mod_endrun()
{
    output_file->cd();
    
    auto slice = TH3Slicer::Slice(sbp_image);        
    sbp_image->Write();
    for ( auto itr : slice ) itr->Write();

    for ( auto image : mlem_image ) {
	auto slices = TH3Slicer::Slice( image );
	for ( auto itr : slices ) itr->Write();
	image->Write();
    }
    
    output_file->Close();    
    input_file->Close();
    return anl::ANL_OK;
}

TH3F* IterateCone3D::next_image(TH3F* previous_image)
{
    // vector_integral_of_multiple.clear();

    auto new_image = (TH3F*)previous_image->Clone();
    auto iteration = (int)mlem_image.size();
    new_image->SetName( Form( "mlem_image_iter%03d", iteration) );
    
    long current_entry = -1;
    event.init_entry();
    
    while ( event.next() ) {
	
	++current_entry;

	auto multiple = (TH3F*)event.response->Clone();
	multiple->Multiply( previous_image );

	auto integral = multiple->Integral();
	// vector_integral_of_multiple.emplace_back( integral );

	auto tempo = (TH3F*)event.response->Clone();
	tempo->Scale( vector_integral_of_response[ current_entry ] /
		      ( integral + denominator_offset ) );
	
	new_image->Add( tempo );

	multiple->Delete();
	tempo->Delete();
	
    }
    
    new_image->Multiply( previous_image );
    
    return new_image;
}



std::vector<TH2D*> IterateCone3D::TH3Slicer::Slice(TH3F* th3)
{
    std::vector<TH2D*> list_of_slices;
    if ( !th3 ) return list_of_slices;    

    TH2D * frame = define_slice(th3);
    TString hname = th3->GetName();

    std::map<int, TAxis*> axis;
    axis[0] = th3->GetXaxis();
    axis[1] = th3->GetYaxis();
    axis[2] = th3->GetZaxis();

    int slice_axis = 2;
    int xaxis = (slice_axis+1)%3;
    int yaxis = (slice_axis+2)%3;

    auto nbinsx = axis[xaxis]->GetNbins();
    auto nbinsy = axis[yaxis]->GetNbins();
    auto nbinsz = axis[slice_axis]->GetNbins();
    
    for ( int islice=1; islice<nbinsz+1; ++islice ) {

	auto slice = (TH2D*)frame->Clone();
	auto slicez = axis[slice_axis]->GetBinCenter( islice );
	
	TString sname = Form( hname+"_slice_%04d", islice );
	TString title = Form( "slice of "+hname+" at %.3f", slicez );
	slice->SetNameTitle( sname, title );	
	
	for ( int ix=1; ix<nbinsx+1; ix++ ) {
	    
	    for ( int iy=1; iy<nbinsy+1; iy++ ) {
		
		auto content = th3->GetBinContent( ix, iy, islice );		
		slice->SetBinContent( ix, iy, content );
		
	    }
	}
	list_of_slices.emplace_back( slice );
    }
    
    return list_of_slices;
}

TH2D* IterateCone3D::TH3Slicer::define_slice(TH3F* th3, int slice_axis)
{
    // auto xaxis = th3->GetXaxis();
    // auto yaxis = th3->GetYaxis();
    // auto zaxis = th3->GetZaxis();

    std::map<int, TAxis*> axis;
    axis[0] = th3->GetXaxis();
    axis[1] = th3->GetYaxis();
    axis[2] = th3->GetZaxis();

    std::vector<double> axis_min;
    std::vector<double> axis_max;
    std::vector<int> axis_nbins;    
    
    for ( int i=1; i<3; ++i ) {
	int iaxis = (slice_axis+i)%3;
	axis_min.emplace_back( axis[iaxis]->GetXmin() );
	axis_max.emplace_back( axis[iaxis]->GetXmax() );
	axis_nbins.emplace_back( axis[iaxis]->GetNbins() );
    }

    TString hname = (TString)th3->GetName()+"_slice_frame";
    auto h2 = new TH2D( hname, hname,
			axis_nbins[0], axis_min[0], axis_max[0],
			axis_nbins[1], axis_min[1], axis_max[1] );

    return h2;
}
