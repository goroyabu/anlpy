/**
   @file   IterateCone3D.cpp
   @date   2020/05/12
   @author
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "IterateCone3D.hpp"

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <chrono>

#include <TChain.h>
#include <TChainElement.h>

#include <bnk.hpp>
#include <evs.hpp>

IterateCone3D::IterateCone3D()
    : anl::VANL_Module("IterateCone3D", "0.1"),
      input_file(nullptr), input_tree(nullptr), output_file(nullptr), sbp_image(nullptr)
{
    /** Parameters can be modified via a method 'SetParameter' in Python **/
    // define_parameter<std::string>("input_file", "input.txt");
    define_parameter<std::string>("input_file", "input.root");
    define_parameter<std::string>("input_tree", "resptree");
    define_parameter<std::string>("output_file", "output.root");
    define_parameter<int>("n_of_iterations", 0);
    define_parameter<double>("denominator_offset", 10.0);
    define_parameter<int>("eventid", -1);

    define_parameter<int>("last_entry", -1);
    define_parameter<int>("first_entry", 0);

    define_parameter<int>( "use_2d_reconstruction", 0 );
    define_parameter<int>( "index_of_2d_image", -1 );

    define_parameter<int>("n_threads", 1);

    define_parameter<int>("use_sbp_as_efficiency", false);
}
IterateCone3D::~IterateCone3D()
{
}

int IterateCone3D::mod_bgnrun()
{
    auto input_file_name = get_parameter<std::string>("input_file");
    auto input_tree_name = get_parameter<std::string>("input_tree");

    auto chain = new TChain( input_tree_name.c_str() );
    chain->Add( input_file_name.c_str() );
    if ( chain->GetNtrees()==0 ) {
	cout << input_tree_name << " is not found in " << input_file_name << endl;
	return anl::ANL_NG;
    }

    int ifile = 0;
    auto list_of_files = chain->GetListOfFiles();
    TIter next(list_of_files);
    TChainElement * elem = 0;
    while ( (elem = (TChainElement*)next() ) ) {
	cout << "File" << ifile << " : " << elem->GetTitle() << endl;
    }

    auto nentries = event.set_branch_address( chain );
    if ( nentries==0 ) {
	cout << input_tree_name << " has NO event." << endl;
	return anl::ANL_NG;
    }
    cout << "# of entries in " << input_tree_name << " is " << nentries << endl;

    auto ofname = get_parameter<std::string>("output_file");
    output_file = new TFile( ofname.c_str(), "recreate" );
    if ( !output_file || output_file->IsZombie() ) {
        cout << "Creating " << ofname << " is failed." << endl;
        return anl::ANL_NG;
    }
    cout << ofname << " is created." << endl;

    sbp_image = (TH3F*)event.response->Clone();
    sbp_image->Reset();
    sbp_image->SetName("sbp_image");

    nbins_xaxis = sbp_image->GetXaxis()->GetNbins();
    nbins_yaxis = sbp_image->GetYaxis()->GetNbins();
    nbins_zaxis = sbp_image->GetZaxis()->GetNbins();

    n_of_iterations = get_parameter<int>("n_of_iterations");

    denominator_offset = get_parameter<double>("denominator_offset");
    is_enabled_use_sbp_as_efficiency = get_parameter<int>("use_sbp_as_efficiency");

    eventid = get_parameter<int>("eventid");
    current_entry = -1;

    auto first_entry = get_parameter<int>("first_entry");
    auto last_entry = get_parameter<int>("last_entry");
    event.set_entry_range(first_entry, last_entry);

    index_of_2d_image = get_parameter<int>( "index_of_2d_image" );
    is_enabled_2d_reconstruction = get_parameter<int>( "use_2d_reconstruction" );

    n_threads = get_parameter<int>("n_threads");
    if ( n_threads<=0 ) n_threads = 1;

    is_enabled_multiple_thread = false;
    if ( n_threads>1 ) {
	is_enabled_multiple_thread = true;
	cout << "Multiple Thread Mode is enabled (N=" << n_threads << ")" << endl;
    }

    if ( is_enabled_multiple_thread ) {

	int xdiv = nbins_xaxis/n_threads;
	int xbgn = 0;
	int xend = 0 + xdiv;

	for ( int ithre=0; ithre<n_threads-1; ++ithre ) {
	    list_of_xbin_ranges.emplace_back( std::make_pair(xbgn, xend) );
	    xbgn = xend + 1;
	    xend += xdiv;
	}
	if ( xbgn<nbins_xaxis-1) {
	    list_of_xbin_ranges
		.emplace_back( std::make_pair(xbgn, nbins_xaxis-1) );
	}
    }

    h1_integral_event_response = new TH1D(
        "h1_integral_event_response", "integral of event response",
        3000, -1, 2 );
    h1_integral_image_cross_response = new TH1D(
        "h1_integral_image_cross_response", "integral of image cross response",
        3000, -1, 2 );
    h2_response_vs_image_cross_response = new TH2D(
        "h2_response_vs_image_cross_response",
        ";integral of response;integral of image cross response",
        300, -1, 2, 300, -1, 2 );

    return anl::ANL_OK;
}

int IterateCone3D::mod_ana()
{

    if ( n_of_iterations == 0 ) {

	auto x = event.response->GetXaxis()->GetNbins();
	auto y = event.response->GetYaxis()->GetNbins();
	auto z = event.response->GetZaxis()->GetNbins();

	vector3 new_elems = make_vector3( x, y, z, 0.0 );

	while ( event.next() ) {
	    ++current_entry;
	    if ( eventid>=0 && eventid>current_entry ) continue;
	    if ( eventid>=0 && eventid<current_entry ) return anl::ANL_LOOP;
	    // sbp_image->Add( event.response );
	    h2v_add_elements( event.response, &new_elems );
	}

	v2h_set_elements( new_elems, sbp_image );

	return anl::ANL_LOOP;
    }
    else {

	auto x = event.response->GetXaxis()->GetNbins();
	auto y = event.response->GetYaxis()->GetNbins();
	auto z = event.response->GetZaxis()->GetNbins();

	vector3 sbp_elems = make_vector3( x, y, z, 0.0 );
	vector3 temp_elems = make_vector3( x, y, z, 0.0 );

	while ( event.next() ) {

	    h2v_get_elements( event.response, &temp_elems );

	    v2v_add_elements( temp_elems, &sbp_elems );

	    auto integral = get_integral( temp_elems );

	    vector_integral_of_response.emplace_back( integral );
        this->h1_integral_event_response->Fill( integral );
	}

	v2h_set_elements( sbp_elems, sbp_image );
	sbp_elems.clear();
	sbp_elems.shrink_to_fit();
	temp_elems.clear();
	temp_elems.shrink_to_fit();
    }

    cout << "first backprojection is done" << endl;

    mlem_image.reserve( n_of_iterations );

    auto new_image = next_image( sbp_image );
    mlem_image.emplace_back( new_image );

    if ( n_of_iterations>1 )
	cout << "1/" << n_of_iterations << "iteration is done" << endl;

    for ( int iteration=1; iteration<n_of_iterations; ++iteration ) {

	auto new_image = next_image( mlem_image[ iteration-1 ] );
	mlem_image.emplace_back( new_image );
	// std::this_thread::sleep_for(std::chrono::milliseconds(3000));

	cout << iteration+1 << "/" << n_of_iterations;
	cout << " iteration is done" << endl;
    }

    return anl::ANL_LOOP;
}

int IterateCone3D::mod_endrun()
{
    output_file->cd();

    auto slice = TH3Slicer::Slice(sbp_image);
    sbp_image->Write();
    for ( auto itr : slice ) itr->Write();

    for ( auto image : mlem_image ) {
	auto slices = TH3Slicer::Slice( image );
	for ( auto itr : slices ) itr->Write();
	image->Write();
    }

    for ( auto image : diff_image ) {
	auto slices = TH3Slicer::Slice( image );
	for ( auto itr : slices ) itr->Write();
	image->Write();
    }

    for ( auto image : list_of_images_cross_response ) {
        auto slices = TH3Slicer::Slice( image );
        for ( auto itr : slices ) itr->Write();
        image->Write();
    }

    this->h1_integral_event_response->Write();
    this->h1_integral_image_cross_response->Write();
    this->h2_response_vs_image_cross_response->Write();

    output_file->Close();
    // input_file->Close();
    return anl::ANL_OK;
}

IterateCone3D::vector3 IterateCone3D::make_vector3
(int x, int y, int z, double value)
{
    vector3 out;
    out.resize(x);
    for ( auto&& itr : out ) {
	itr.resize(y);
	for ( auto&& subitr : itr ) subitr.resize(z);
    }
    return out;
}

void IterateCone3D::h2v_get_elements
(TH3F* th3, vector3* out)
{
    (*out).resize(nbins_xaxis);
    for ( auto&& v2d : *out ) {
    	v2d.resize(nbins_yaxis);
    	for ( auto&& v1d : v2d ) v1d.resize(nbins_zaxis);
    }

    if ( is_enabled_multiple_thread==false ) {

	for ( int x=1; x<=nbins_xaxis; ++x ) {
	    for ( int y=1; y<=nbins_yaxis; ++y ) {
		for ( int z=1; z<=nbins_zaxis; ++z ) {
            if ( this->is_enabled_2d_reconstruction && z!=this->index_of_2d_image )
                continue;
            (*out)[x-1][y-1][z-1] = th3->GetBinContent(x,y,z);
		}
	    }
	}
    	return;
    }

    else {

	std::vector<std::thread> threads;

	for ( auto [ xbgn, xend ] : list_of_xbin_ranges ) {

	    threads.emplace_back( std::thread( &h2v_get_elem_impl,
            th3, out, xbgn+1, xend+1,
            nbins_yaxis, nbins_zaxis,
            this->is_enabled_2d_reconstruction,
            this->index_of_2d_image ) );

	}

    	for( auto& thread : threads ) thread.join();

    }
}

void IterateCone3D::h2v_add_elements(TH3F* th3, vector3* out)
{
    auto nx = nbins_xaxis;
    auto ny = nbins_yaxis;
    auto nz = nbins_zaxis;

    (*out).resize(nx);
    for ( auto&& v2d : *out ) {
    	v2d.resize(ny);
    	for ( auto&& v1d : v2d ) v1d.resize(nz);
    }

    for ( int x=1; x<=nx; ++x ) {
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {
            if ( this->is_enabled_2d_reconstruction && z!=this->index_of_2d_image )
                continue;
            (*out)[x-1][y-1][z-1] += th3->GetBinContent(x,y,z);
	    }
	}
    }
}

// void IterateCone3D::add_elements
// (const vector3& in, TH3F* th3)
// {
//     auto nx = (int)in.size();
//     if ( nx==0 ) return;
//     auto ny = (int)in[0].size();
//     if ( ny==0 ) return;
//     auto nz = (int)in[0][0].size();

//     for ( int x=1; x<=nx; ++x ) {
// 	for ( int y=1; y<=ny; ++y ) {
// 	    for ( int z=1; z<=nz; ++z ) {
// 		th3->SetBinContent( x, y, z,
// 				    in[x-1][y-1][z-1] + th3->GetBinContent(x,y,z) );
// 	    }
// 	}
//     }
// }

void IterateCone3D::v2h_set_elements
(const vector3& in, TH3F* th3)
{
    auto nx = (int)in.size();
    if ( nx==0 ) {
	cerr << "***Error*** in IterateCone3D::v2h_set_elements : vector has no element" << endl;
	return;
    }
    auto ny = (int)in[0].size();
    if ( ny==0 ) {
	cerr << "***Error*** in IterateCone3D::v2h_set_elements : vector has no element" << endl;
	return;
    }
    auto nz = (int)in[0][0].size();

    for ( int x=1; x<=nx; ++x ) {
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {
            th3->SetBinContent( x, y, z, in[x-1][y-1][z-1] );
	    }
	}
    }
}

void IterateCone3D::v2v_add_elements(const vector3& in, vector3* out)
{
    auto nx = (int)in.size();
    if ( nx==0 ) {
	cerr << "***Error*** in IterateCone3D::v2v_add_elements : vector has no element" << endl;
	return;
    }
    auto ny = (int)in[0].size();
    if ( ny==0 ) {
	cerr << "***Error*** in IterateCone3D::v2v_add_elements : vector has no element" << endl;
	return;
    }
    auto nz = (int)in[0][0].size();
    if ( nz==0 ) {
	cerr << "***Error*** in IterateCone3D::v2v_add_elements : vector has no element" << endl;
	return;
    }

    (*out).resize(nx);
    for ( auto x=0; x<nx; ++x ) {
    	(*out)[x].resize(ny);
    	for ( auto y=0; y<ny; ++y ) {
    	    (*out)[x][y].resize(nz);
	}
    }

    for ( auto x=0; x<nx; ++x ) {
	for ( auto y=0; y<ny; ++y ) {
	    for ( auto z=0; z<nz; ++z ) {
            (*out)[x][y][z] += in[x][y][z];
	    }
	}
    }
}

double IterateCone3D::get_integral(const vector3& in)
{
    double sum = 0.0;
    // for ( auto&& v2 : in )
    // 	for ( auto&& v1 : v2 )
    // 	    for ( auto&& elem : v1 ) sum += elem;
    for ( auto v2 : in )
        for ( auto v1 : v2 ) {
            // int z = 1;
            for ( auto elem : v1 ) {
                // if ( this->is_enabled_2d_reconstruction && z!=this->index_of_2d_image )
                //     continue;
                sum += elem;
                // z++;
            }
        }
    return sum;
}

// void IterateCone3D::copy_elements(const vector3& in, vector3* out)
// {
//     auto nx = (int)(*out).size();
//     if ( nx==0 ) return;
//     // if ( nx==0 || nx!=(int)in.size() ) return;
//     auto ny = (int)(*out)[0].size();
//     if ( ny==0 ) return;
//     // if ( ny==0 || ny!=(int)in[0].size() ) return;
//     auto nz = (int)(*out)[0][0].size();
//     if ( nz==0 ) return;
//     // if ( nz==0 || nz!=(int)in[0][0].size() ) return;

//     (*out).resize(nx);
//     for ( auto x=0; x<nx; ++x ) {
// 	(*out)[x].resize(ny);
// 	for ( auto y=0; y<ny; ++y ) {
// 	    (*out)[x][y].resize(nz);
// 	    for ( auto z=0; z<nz; ++z ) {
// 		(*out)[x][y][z] = in[x][y][z];
// 	    }
// 	}
//     }
// }

void IterateCone3D::scale_elements(double factor, vector3* out)
{
    for ( auto&& v2 : *out )
	for ( auto&& v1 : v2 )
	    for ( auto&& elem : v1 ) elem = elem*factor;
}

void IterateCone3D::v2v_multiply_elements(const vector3& in, vector3* out)
{
    auto nx = (int)(*out).size();
    if ( nx==0 || nx!=(int)in.size() ) {
	cerr << "***Error*** in IterateCone3D::v2v_multiply_elements : mismatching size of vector" << endl;
	return;
    }
    auto ny = (int)(*out)[0].size();
    if ( ny==0 || ny!=(int)in[0].size() ) {
	cerr << "***Error*** in IterateCone3D::v2v_multiply_elements : mismatching size of vector" << endl;
	return;
    }
    auto nz = (int)(*out)[0][0].size();
    if ( nz==0 || nz!=(int)in[0][0].size() ) {
	cerr << "***Error*** in IterateCone3D::v2v_multiply_elements : mismatching size of vector" << endl;
	return;
    }

    for ( auto x=0; x<nx; ++x )
	for ( auto y=0; y<ny; ++y )
	    for ( auto z=0; z<nz; ++z )
		(*out)[x][y][z] *= in[x][y][z];
}

void IterateCone3D::v2v_divide_elements(const vector3& in, vector3* out)
{
    auto nx = (int)(*out).size();
    if ( nx==0 || nx!=(int)in.size() ) {
	cerr << "***Error*** in IterateCone3D::v2v_divide_elements : mismatching size of vector" << endl;
	return;
    }
    auto ny = (int)(*out)[0].size();
    if ( ny==0 || ny!=(int)in[0].size() ) {
	cerr << "***Error*** in IterateCone3D::v2v_divide_elements : mismatching size of vector" << endl;
	return;
    }
    auto nz = (int)(*out)[0][0].size();
    if ( nz==0 || nz!=(int)in[0][0].size() ) {
	cerr << "***Error*** in IterateCone3D::v2v_divide_elements : mismatching size of vector" << endl;
	return;
    }

    for ( auto x=0; x<nx; ++x )
	for ( auto y=0; y<ny; ++y )
	    for ( auto z=0; z<nz; ++z ) {
		if ( in[x][y][z]<0.000000001 )
		    (*out)[x][y][z] = 0.0;
		else
		    (*out)[x][y][z] /= in[x][y][z];
	    }
}

void IterateCone3D::h2v_get_elem_impl
(TH3F* th3, vector3* out, int x1, int x2, int ny, int nz, bool is_2dimage, int index_of_z)
{
    for ( int x=x1; x<=x2; ++x ) {
        for ( int y=1; y<=ny; ++y ) {
            if ( is_2dimage ) {
                (*out)[x-1][y-1][index_of_z-1] = th3->GetBinContent( x, y, index_of_z );
            }
            else {
                for ( int z=1; z<=nz; ++z ) {
                    (*out)[x-1][y-1][z-1] = th3->GetBinContent(x,y,z);
                }
            }
        }
    }
}

// void IterateCone3D::v2v_multi_elem_impl
// (const vector3& in, vector3* out, int x1, int x2, int ny, int nz)
// {
//     for ( int x=x1; x<=x2; ++x ) {
// 	for ( int y=0; y<ny; ++y ) {
// 	    for ( int z=0; z<nz; ++z ) {
// 		(*out)[x][y][z] *= in[x][y][z];
// 	    }
// 	}
//     }
// }

// void IterateCone3D::v2v_add_elem_impl
// (const vector3& in, vector3* out, int x1, int x2, int ny, int nz)
// {
//     for ( int x=x1; x<=x2; ++x ) {
// 	for ( int y=0; y<ny; ++y ) {
// 	    for ( int z=0; z<nz; ++z ) {
// 		// (*out)[x][y][z] += (*out)[x][y][z] + in[x][y][z];
// 		(*out)[x][y][z] = (*out)[x][y][z] + in[x][y][z];
// 	    }
// 	}
//     }
// }

// void IterateCone3D::v2v_modify_element
// (const vector3& in, vector3* out, int x1, int x2, int ny, int nz,
//  std::function<void(const float, float*)> func)
// {
//     for ( int x=x1; x<=x2; ++x ) {
// 	for ( int y=1; y<=ny; ++y ) {
// 	    for ( int z=1; z<=nz; ++z ) {
// 		func( in[x][y][z], &(*out)[x][y][z] );
// 		// (*out)[x][y][z] += in[x][y][z];
// 	    }
// 	}
//     }
// }

TH3F* IterateCone3D::next_image(TH3F* previous_image)
{
    auto new_image = (TH3F*)previous_image->Clone();
    new_image->Reset();

    vector3 new_elems;
    h2v_get_elements( new_image, &new_elems );

    auto iteration = (int)mlem_image.size();
    new_image->SetName( Form( "mlem_image_iter%03d", iteration) );

    vector3 prev_elems;
    h2v_get_elements( previous_image, &prev_elems );

    vector3 temp_elems, temp2_elems;

    long current_entry = -1;
    event.init_entry();

    while ( event.next() ) {

        ++current_entry;

	    h2v_get_elements( event.response, &temp_elems );

        temp2_elems = temp_elems;

        v2v_multiply_elements( prev_elems, &temp_elems );

        auto integral = get_integral( temp_elems );
        auto integral_of_current_response = get_integral( temp2_elems );

        this->h1_integral_image_cross_response->Fill( integral );
        this->h2_response_vs_image_cross_response
            ->Fill( integral_of_current_response, integral );

        int n_images_cross_response = list_of_images_cross_response.size();
        if ( n_images_cross_response < 10 ) {
            auto image_cross_reponse = (TH3F*)new_image->Clone();
            image_cross_reponse->Reset();
            image_cross_reponse->SetName( Form(
                "image_cross_reponse_iter%03d_e%03d",
                iteration, n_images_cross_response ) );
                v2h_set_elements( temp_elems, image_cross_reponse );
                list_of_images_cross_response
                    .emplace_back( image_cross_reponse );
            }

        // scale_elements
        //     ( vector_integral_of_response[ current_entry ]/( integral + denominator_offset ),
        //       &temp2_elems );

        if ( integral_of_current_response==0.0 )
            std::cout << current_entry << " 0" << std::endl;
        if ( integral==0.0 )
            std::cout << current_entry << " 0" << std::endl;

        if ( integral==0.0 || integral_of_current_response==0.0 )
            continue;

        scale_elements
            ( integral_of_current_response/( integral + denominator_offset ),
            &temp2_elems );

        v2v_add_elements( temp2_elems, &new_elems );

        //auto multiple = (TH3F*)event.response->Clone();
        //multiple->Multiply( previous_image );
        // auto integral = multiple->Integral();
        // auto tempo = (TH3F*)event.response->Clone();
        // tempo->Scale( vector_integral_of_response[ current_entry ] /
        // 	      ( integral + denominator_offset ) );
        // new_image->Add( tempo );
    }
    cout << "Integration over all events is done." << endl;

    auto diff_new_and_previous = (TH3F*)previous_image->Clone();
    diff_new_and_previous->SetName( Form( "diff_image_prev_and_iter%03d", iteration) );
    diff_new_and_previous->Reset();
    v2h_set_elements( new_elems, diff_new_and_previous );
    diff_image.emplace_back( diff_new_and_previous );

    v2v_multiply_elements( prev_elems, &new_elems );
    cout << "Multiplying by previous image is done." << endl;

    if ( this->is_enabled_use_sbp_as_efficiency==true ) {
	vector3 sbp_elems;
	h2v_get_elements( sbp_image, &sbp_elems );
	v2v_divide_elements( sbp_elems, &new_elems );
	cout << "Dividing by simple back-projection is done" << endl;
    }

    v2h_set_elements( new_elems, new_image );
    return new_image;

    // new_image->Multiply( previous_image );

    // temp_elems.clear();
    // temp_elems.shrink_to_fit();
    // temp2_elems.clear();
    // temp2_elems.shrink_to_fit();
    // new_elems.clear();
    // new_elems.shrink_to_fit();
    // prev_elems.clear();
    // prev_elems.shrink_to_fit();
}

std::vector<TH2D*> IterateCone3D::TH3Slicer::Slice(TH3F* th3)
{
    std::vector<TH2D*> list_of_slices;
    if ( !th3 ) return list_of_slices;

    TH2D * frame = define_slice(th3);
    TString hname = th3->GetName();

    std::map<int, TAxis*> axis;
    axis[0] = th3->GetXaxis();
    axis[1] = th3->GetYaxis();
    axis[2] = th3->GetZaxis();

    int slice_axis = 2;
    int xaxis = (slice_axis+1)%3;
    int yaxis = (slice_axis+2)%3;

    auto nbinsx = axis[xaxis]->GetNbins();
    auto nbinsy = axis[yaxis]->GetNbins();
    auto nbinsz = axis[slice_axis]->GetNbins();

    for ( int islice=1; islice<nbinsz+1; ++islice ) {

	auto slice = (TH2D*)frame->Clone();
	auto slicez = axis[slice_axis]->GetBinCenter( islice );

	TString sname = Form( hname+"_slice_%04d", islice );
	TString title = Form( "slice of "+hname+" at %.3f", slicez );
	slice->SetNameTitle( sname, title );

	for ( int ix=1; ix<nbinsx+1; ix++ ) {

	    for ( int iy=1; iy<nbinsy+1; iy++ ) {

		auto content = th3->GetBinContent( ix, iy, islice );
		slice->SetBinContent( ix, iy, content );

	    }
	}
	list_of_slices.emplace_back( slice );
    }

    return list_of_slices;
}

TH2D* IterateCone3D::TH3Slicer::define_slice(TH3F* th3, int slice_axis)
{
    // auto xaxis = th3->GetXaxis();
    // auto yaxis = th3->GetYaxis();
    // auto zaxis = th3->GetZaxis();

    std::map<int, TAxis*> axis;
    axis[0] = th3->GetXaxis();
    axis[1] = th3->GetYaxis();
    axis[2] = th3->GetZaxis();

    std::vector<double> axis_min;
    std::vector<double> axis_max;
    std::vector<int> axis_nbins;

    for ( int i=1; i<3; ++i ) {
	int iaxis = (slice_axis+i)%3;
	axis_min.emplace_back( axis[iaxis]->GetXmin() );
	axis_max.emplace_back( axis[iaxis]->GetXmax() );
	axis_nbins.emplace_back( axis[iaxis]->GetNbins() );
    }

    TString hname = (TString)th3->GetName()+"_slice_frame";
    auto h2 = new TH2D( hname, hname,
			axis_nbins[0], axis_min[0], axis_max[0],
			axis_nbins[1], axis_min[1], axis_max[1] );

    return h2;
}
