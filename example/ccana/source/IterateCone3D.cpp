/**
   @file   IterateCone3D.cpp
   @date   2020/05/12
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "IterateCone3D.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <chrono>

#include <TChain.h>
#include <TChainElement.h>

#include <bnk.hpp>
#include <evs.hpp>

IterateCone3D::IterateCone3D()
    : anl::VANL_Module("IterateCone3D", "0.1"),
      input_file(nullptr), input_tree(nullptr), output_file(nullptr), sbp_image(nullptr)
{
    /** Parameters can be modified via a method 'SetParameter' in Python **/
    // define_parameter<std::string>("input_file", "input.txt");
    define_parameter<std::string>("input_file", "input.root");
    define_parameter<std::string>("input_tree", "resptree");
    define_parameter<std::string>("output_file", "output.root");
    define_parameter<int>("n_of_iterations", 0);
    define_parameter<double>("denominator_offset", 10.0);
    define_parameter<int>("eventid", -1);

    define_parameter<int>("last_entry", -1);
    define_parameter<int>("first_entry", 0);

    define_parameter<int>("n_threads", 1);

    define_parameter<int>("use_sbp_as_efficiency", false);
}
IterateCone3D::~IterateCone3D()
{
}

int IterateCone3D::mod_bgnrun()
{
    auto input_file_name = get_parameter<std::string>("input_file");
    // input_file = new TFile( input_file_name.c_str() );
    // if ( !input_file || input_file->IsZombie() ) {
    // 	cout << "Opening " << input_file_name << " is failed." << endl;
    // 	return anl::ANL_NG;
    // }
    // cout << input_file_name << " is opened." << endl;

    auto input_tree_name = get_parameter<std::string>("input_tree");
    // input_tree = (TTree*)input_file->Get( input_tree_name.c_str() );
    // if ( !input_tree ) {
    // 	cout << input_tree_name << " is not found." << endl;
    // 	return anl::ANL_NG;
    // }

    auto chain = new TChain( input_tree_name.c_str() );
    chain->Add( input_file_name.c_str() );
    if ( chain->GetNtrees()==0 ) {
	cout << input_tree_name << " is not found in " << input_file_name << endl;
	return anl::ANL_NG;
    }    

    int ifile = 0;
    auto list_of_files = chain->GetListOfFiles();
    TIter next(list_of_files);
    TChainElement * elem = 0;
    while ( (elem = (TChainElement*)next() ) ) {
	cout << "File" << ifile << " : " << elem->GetTitle() << endl;
    }    
    
    // auto nentries = event.set_branch_address(input_tree);
    auto nentries = event.set_branch_address( chain );
    if ( nentries==0 ) {
	cout << input_tree_name << " has NO event." << endl;
	return anl::ANL_NG;
    }
    cout << "# of entries in " << input_tree_name << " is " << nentries << endl;
    
    auto ofname = get_parameter<std::string>("output_file");
    output_file = new TFile( ofname.c_str(), "recreate" );
    if ( !output_file || output_file->IsZombie() ) {
        cout << "Creating " << ofname << " is failed." << endl;
        return anl::ANL_NG;
    }
    cout << ofname << " is created." << endl;

    sbp_image = (TH3F*)event.response->Clone();
    sbp_image->Reset();
    sbp_image->SetName("sbp_image");

    nbins_xaxis = sbp_image->GetXaxis()->GetNbins();
    nbins_yaxis = sbp_image->GetYaxis()->GetNbins();
    nbins_zaxis = sbp_image->GetZaxis()->GetNbins();
    
    n_of_iterations = get_parameter<int>("n_of_iterations");

    denominator_offset = get_parameter<double>("denominator_offset");
    is_enabled_use_sbp_as_efficiency = get_parameter<int>("use_sbp_as_efficiency");
    
    eventid = get_parameter<int>("eventid");
    current_entry = -1;

    auto first_entry = get_parameter<int>("first_entry");
    auto last_entry = get_parameter<int>("last_entry");
    event.set_entry_range(first_entry, last_entry);

    n_threads = get_parameter<int>("n_threads");
    if ( n_threads<=0 ) n_threads = 1;

    is_enabled_multiple_thread = false;
    if ( n_threads>1 ) {
	is_enabled_multiple_thread = true;
	cout << "Multiple Thread Mode is enabled (N=" << n_threads << ")" << endl;
    }

    if ( is_enabled_multiple_thread ) {

	int xdiv = nbins_xaxis/n_threads;
	int xbgn = 0;
	int xend = 0 + xdiv;
	
	for ( int ithre=0; ithre<n_threads-1; ++ithre ) { 
	    list_of_xbin_ranges.emplace_back( std::make_pair(xbgn, xend) );
	    xbgn = xend + 1;
	    xend += xdiv;
	}
	if ( xbgn<nbins_xaxis-1) {
	    list_of_xbin_ranges
		.emplace_back( std::make_pair(xbgn, nbins_xaxis-1) );
	}
    }
    
    return anl::ANL_OK;
}

int IterateCone3D::mod_ana()
{
    // if ( !event.next() ) return anl::ANL_LOOP;
    // while ( event.next() ) {    
    // 	sbp_image->Add( event.response );
    // }

    if ( n_of_iterations == 0 ) {

	auto x = event.response->GetXaxis()->GetNbins();
	auto y = event.response->GetYaxis()->GetNbins();
	auto z = event.response->GetZaxis()->GetNbins();

	vector3 new_elems = make_vector3( x, y, z, 0.0 );	
	
	while ( event.next() ) {
	    ++current_entry;
	    if ( eventid>=0 && eventid>current_entry ) continue;
	    if ( eventid>=0 && eventid<current_entry ) return anl::ANL_LOOP;
	    // sbp_image->Add( event.response );
	    h2v_add_elements( event.response, &new_elems );
	}

	v2h_set_elements( new_elems, sbp_image );
	
	return anl::ANL_LOOP;
    }
    else {
	
	auto x = event.response->GetXaxis()->GetNbins();
	auto y = event.response->GetYaxis()->GetNbins();
	auto z = event.response->GetZaxis()->GetNbins();
	
	vector3 sbp_elems = make_vector3( x, y, z, 0.0 );
	vector3 temp_elems = make_vector3( x, y, z, 0.0 );
	
	while ( event.next() ) {
	    // sbp_image->Add( event.response );
	    // auto integral = event.response->Integral();

	    // cout << "get" << endl;
	    h2v_get_elements( event.response, &temp_elems );

	    // cout << "add" << endl;
	    v2v_add_elements( temp_elems, &sbp_elems );

	    // cout << "integral" << endl;
	    auto integral = get_integral( temp_elems );
	    
	    vector_integral_of_response.emplace_back( integral );
	}

	// cout << "set" << endl;
	v2h_set_elements( sbp_elems, sbp_image );
	sbp_elems.clear();
	sbp_elems.shrink_to_fit();
	temp_elems.clear();
	temp_elems.shrink_to_fit();
    }

    cout << "first backprojection is done" << endl;
    
    mlem_image.reserve( n_of_iterations );
    
    auto new_image = next_image( sbp_image );
    // auto new_image = (TH3F*)sbp_image->Clone();
    mlem_image.emplace_back( new_image );
    if ( n_of_iterations>1 ) 
	cout << "1/" << n_of_iterations << "iteration is done" << endl;    
    
    for ( int iteration=1; iteration<n_of_iterations; ++iteration ) {
	
	auto new_image = next_image( mlem_image[ iteration-1 ] );
	// auto new_image = (TH3F*)sbp_image->Clone();
	mlem_image.emplace_back( new_image );
	// std::this_thread::sleep_for(std::chrono::milliseconds(3000));

	// auto new_image = 
	// mlem_image.emplace_back( next_image( mlem_image[ iteration-1 ] ) );

	
	cout << iteration+1 << "/" << n_of_iterations;
	cout << " iteration is done" << endl;	
    }    
    
    return anl::ANL_LOOP;
}

int IterateCone3D::mod_endrun()
{
    output_file->cd();
    
    auto slice = TH3Slicer::Slice(sbp_image);        
    sbp_image->Write();
    for ( auto itr : slice ) itr->Write();

    for ( auto image : mlem_image ) {
	auto slices = TH3Slicer::Slice( image );
	for ( auto itr : slices ) itr->Write();
	image->Write();
    }

    for ( auto image : diff_image ) {
	auto slices = TH3Slicer::Slice( image );
	for ( auto itr : slices ) itr->Write();
	image->Write();
    }
    
    output_file->Close();    
    // input_file->Close();
    return anl::ANL_OK;
}

IterateCone3D::vector3 IterateCone3D::make_vector3
(int x, int y, int z, double value)
{
    vector3 out;
    out.resize(x);
    for ( auto&& itr : out ) {
	itr.resize(y);
	for ( auto&& subitr : itr ) subitr.resize(z);
    }
    return out;
}


void IterateCone3D::h2v_get_elements
(TH3F* th3, vector3* out)
{
    // auto nx = th3->GetXaxis()->GetNbins();
    // auto ny = th3->GetYaxis()->GetNbins();
    // auto nz = th3->GetZaxis()->GetNbins();
    
    (*out).resize(nbins_xaxis);
    for ( auto&& v2d : *out ) {
    	v2d.resize(nbins_yaxis);
    	for ( auto&& v1d : v2d ) v1d.resize(nbins_zaxis);
    }    

    // //     cout << (*out).size() << endl;
    // cout << (*out)[0].size() << endl;
    // cout << (*out)[0][0].size() << endl;
    // cout << "copy for elements" << endl;
    
    if ( is_enabled_multiple_thread==false ) {
	for ( int x=1; x<=nbins_xaxis; ++x ) {
	    for ( int y=1; y<=nbins_yaxis; ++y ) {
		for ( int z=1; z<=nbins_zaxis; ++z ) {
		    (*out)[x-1][y-1][z-1] = th3->GetBinContent(x,y,z);
		}
	}
	}
    	return;
    }    
    
    else {
    	std::vector<std::thread> threads;
	
    	// const int n_thread = 1;
    	// int nx_div = nx/n_threads;//static_cast<int>(nx/n_threads);
    	// int nx_bgn = 1;
    	// int nx_end = 1 + nx_div;
    	// for ( int thre=0; thre<n_threads-1; ++thre ) {
    	//     threads.emplace_back
    	// 	( std::thread( &h2v_get_elem_impl, th3, out, nx_bgn, nx_end, ny, nz) );
    	//     nx_bgn = nx_end + 1;
    	//     nx_end += nx_div;
    	// }
    	// threads.emplace_back
    	//     ( std::thread( &h2v_get_elem_impl, th3, out, nx_bgn, nx, ny, nz) );

    	// cout << threads.size() << endl;
	
	for ( auto [ xbgn, xend ] : list_of_xbin_ranges ) {
	    threads.emplace_back
		( std::thread(&h2v_get_elem_impl,
			      th3, out, xbgn+1, xend+1,
			      nbins_yaxis, nbins_zaxis) );
	}
	
    	for( auto& thread : threads ) thread.join();    
	
    }
}

void IterateCone3D::h2v_add_elements(TH3F* th3, vector3* out)
{
    auto nx = nbins_xaxis;//th3->GetXaxis()->GetNbins();
    auto ny = nbins_yaxis;//th3->GetYaxis()->GetNbins();
    auto nz = nbins_zaxis;//th3->GetZaxis()->GetNbins();

    (*out).resize(nx);
    for ( auto&& v2d : *out ) {
    	v2d.resize(ny);
    	for ( auto&& v1d : v2d ) v1d.resize(nz);
    }    
    
    for ( int x=1; x<=nx; ++x ) {
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {
		(*out)[x-1][y-1][z-1] += th3->GetBinContent(x,y,z);
	    }
	}
    }    
}


void IterateCone3D::add_elements
(const vector3& in, TH3F* th3)
{
    auto nx = (int)in.size();//th3->GetXaxis()->GetNbins();
    if ( nx==0 ) return;
    auto ny = (int)in[0].size();//th3->GetYaxis()->GetNbins();
    if ( ny==0 ) return;
    auto nz = (int)in[0][0].size();//th3->GetZaxis()->GetNbins();
    
    // (*out).resize(nx);
    // for ( auto v2d : *out ) {
    // 	v2d.resize(ny);
    // 	for ( auto v1d : v2d ) v1d.resize(nz);
    // }    
    
    for ( int x=1; x<=nx; ++x ) {
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {		
		th3->SetBinContent
		    ( x, y, z,
		      in[x-1][y-1][z-1] + th3->GetBinContent(x,y,z) );
	    }
	}
    }
}

void IterateCone3D::v2h_set_elements
(const vector3& in, TH3F* th3)
{
    auto nx = (int)in.size();//th3->GetXaxis()->GetNbins();
    if ( nx==0 ) return;
    auto ny = (int)in[0].size();//th3->GetYaxis()->GetNbins();
    if ( ny==0 ) return;
    auto nz = (int)in[0][0].size();//th3->GetZaxis()->GetNbins();
    
    // (*out).resize(nx);
    // for ( auto v2d : *out ) {
    // 	v2d.resize(ny);
    // 	for ( auto v1d : v2d ) v1d.resize(nz);
    // }    
    
    for ( int x=1; x<=nx; ++x ) {
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {		
		th3->SetBinContent( x, y, z, in[x-1][y-1][z-1] );
	    }
	}
    }
}

void IterateCone3D::v2v_add_elements(const vector3& in, vector3* out)
{
    auto nx = (int)in.size();
    if ( nx==0 ) return;
    auto ny = (int)in[0].size();
    if ( ny==0 ) return;
    auto nz = (int)in[0][0].size();
    if ( nz==0 ) return;

    // cout << "resize" << endl;
    (*out).resize(nx);
    for ( auto x=0; x<nx; ++x ) {
    	(*out)[x].resize(ny);
    	for ( auto y=0; y<ny; ++y ) {
    	    (*out)[x][y].resize(nz);
	}
    }

    // if ( is_enabled_multiple_thread==false ) {
    for ( auto x=0; x<nx; ++x ) {	
	for ( auto y=0; y<ny; ++y ) {
	    for ( auto z=0; z<nz; ++z ) {
		(*out)[x][y][z] += in[x][y][z];
	    }
	}
    }
    
    // return;
    
    // }
    // else {
    // 	// cout << "thread" << endl;
    // 	std::vector<std::thread> threads;
	
    // 	// const int n_thread = 1;
    // 	// int nx_div = nx/n_threads;//static_cast<int>(nx/n_threads);
    // 	// int nx_bgn = 0;
    // 	// int nx_end = 0 + nx_div;
	
    // 	// for ( int thre=0; thre<n_threads-1; ++thre ) {
    // 	//     threads.emplace_back
    // 	// 	( std::thread( &v2v_add_elem_impl,
    // 	// 		       in, out, nx_bgn, nx_end, ny, nz ) );	
    // 	//     nx_bgn = nx_end + 1;
    // 	//     nx_end += nx_div;
    // 	// }
    // 	// //if ( nx_bgn<nx-1 )
    // 	// threads.emplace_back
    // 	//     ( std::thread( &v2v_add_elem_impl,
    // 	// 		   in, out, nx_bgn, nx-1, ny, nz ) );

    // 	for ( auto [ xbgn, xend ] : list_of_xbin_ranges ) {
    // 	    threads.emplace_back
    // 		( std::thread(&v2v_add_elem_impl, in, out, xbgn, xend, ny, nz) );
    // 	}
	
    // 	for( auto& thread : threads ) thread.join();
    // }
}

double IterateCone3D::get_integral(const vector3& in)
{
    double sum = 0.0;
    for ( auto&& v2 : in )
	for ( auto&& v1 : v2 )
	    for ( auto&& elem : v1 ) sum += elem;		
    return sum;
}

void IterateCone3D::copy_elements(const vector3& in, vector3* out)
{
    auto nx = (int)(*out).size();
    if ( nx==0 ) return;
    // if ( nx==0 || nx!=(int)in.size() ) return;
    auto ny = (int)(*out)[0].size();
    if ( ny==0 ) return;
    // if ( ny==0 || ny!=(int)in[0].size() ) return;
    auto nz = (int)(*out)[0][0].size();
    if ( nz==0 ) return;
    // if ( nz==0 || nz!=(int)in[0][0].size() ) return;

    (*out).resize(nx);
    for ( auto x=0; x<nx; ++x ) {
	(*out)[x].resize(ny);
	for ( auto y=0; y<ny; ++y ) {
	    (*out)[x][y].resize(nz);
	    for ( auto z=0; z<nz; ++z ) {
		(*out)[x][y][z] = in[x][y][z];
	    }
	}
    }
}

void IterateCone3D::scale_elements(double factor, vector3* out)
{
    for ( auto&& v2 : *out )
	for ( auto&& v1 : v2 )
	    for ( auto&& elem : v1 ) elem = elem*factor;
}

void IterateCone3D::v2v_multiply_elements(const vector3& in, vector3* out)
{
    auto nx = (int)(*out).size();
    if ( nx==0 || nx!=(int)in.size() ) return;
    auto ny = (int)(*out)[0].size();
    if ( ny==0 || ny!=(int)in[0].size() ) return;
    auto nz = (int)(*out)[0][0].size();
    if ( nz==0 || nz!=(int)in[0][0].size() ) return;

    // if ( is_enabled_multiple_thread==false ) {
    for ( auto x=0; x<nx; ++x )
	for ( auto y=0; y<ny; ++y )
	    for ( auto z=0; z<nz; ++z )
		(*out)[x][y][z] *= in[x][y][z];
    
    // return;
    // }
    
    // else {
    // 	std::vector<std::thread> threads;
	
    // 	// const int n_thread = 1;
    // 	//int nx_div = static_cast<int>(nx/n_threads);
    // 	// static int nx_div = nx/n_threads;
    // 	// int nx_bgn = 0;
    // 	// int nx_end = 0 + nx_div;
    // 	// for ( int thre=0; thre<n_threads-1; ++thre ) {
    // 	//     threads.emplace_back
    // 	// 	( std::thread( &v2v_multi_elem_impl,
    // 	// 		       in, out, nx_bgn, nx_end, ny, nz ) );
    // 	//     nx_bgn = nx_end + 1;
    // 	//     nx_end += nx_div;
    // 	// }
    // 	// if ( nx_bgn<nx-1 )
    // 	//     threads.emplace_back
    // 	// 	( std::thread( &v2v_multi_elem_impl,
    // 	// 		       in, out, nx_bgn, nx-1, ny, nz ) );

    // 	for ( auto [ xbgn, xend ] : list_of_xbin_ranges ) {
    // 	    threads.emplace_back
    // 		( std::thread(&v2v_multi_elem_impl, in, out, xbgn, xend, ny, nz) );
    // 	}

	
    // 	for( auto& thread : threads ) thread.join();
    // }
}

void IterateCone3D::v2v_divide_elements(const vector3& in, vector3* out)
{
    auto nx = (int)(*out).size();
    if ( nx==0 || nx!=(int)in.size() ) return;
    auto ny = (int)(*out)[0].size();
    if ( ny==0 || ny!=(int)in[0].size() ) return;
    auto nz = (int)(*out)[0][0].size();
    if ( nz==0 || nz!=(int)in[0][0].size() ) return;

    for ( auto x=0; x<nx; ++x )
	for ( auto y=0; y<ny; ++y )
	    for ( auto z=0; z<nz; ++z ) {
		if ( in[x][y][z]==0.0 )
		    (*out)[x][y][z] = 0.0;
		else 
		    (*out)[x][y][z] /= in[x][y][z];
	    }
}

void IterateCone3D::h2v_get_elem_impl
(TH3F* th3, vector3* out, int x1, int x2, int ny, int nz)
{
    for ( int x=x1; x<=x2; ++x ) {
	// cout << "x=" << x << endl;
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {
		(*out)[x-1][y-1][z-1] = th3->GetBinContent(x,y,z);
	    }
	}
    }
}

void IterateCone3D::v2v_multi_elem_impl
(const vector3& in, vector3* out, int x1, int x2, int ny, int nz)
{
    for ( int x=x1; x<=x2; ++x ) {
	for ( int y=0; y<ny; ++y ) {
	    for ( int z=0; z<nz; ++z ) {
		(*out)[x][y][z] *= in[x][y][z];
	    }
	}
    }
}

void IterateCone3D::v2v_add_elem_impl
(const vector3& in, vector3* out, int x1, int x2, int ny, int nz)
{
    for ( int x=x1; x<=x2; ++x ) {
	for ( int y=0; y<ny; ++y ) {
	    for ( int z=0; z<nz; ++z ) {
		(*out)[x][y][z] += (*out)[x][y][z] + in[x][y][z];
	    }
	}
    }
}

void IterateCone3D::v2v_modify_element
(const vector3& in, vector3* out, int x1, int x2, int ny, int nz,
 std::function<void(const float, float*)> func)
{
    for ( int x=x1; x<=x2; ++x ) {
	for ( int y=1; y<=ny; ++y ) {
	    for ( int z=1; z<=nz; ++z ) {
		func( in[x][y][z], &(*out)[x][y][z] );
		// (*out)[x][y][z] += in[x][y][z];
	    }
	}
    }
}

TH3F* IterateCone3D::next_image(TH3F* previous_image)
{
    // vector_integral_of_multiple.clear();

    auto new_image = (TH3F*)previous_image->Clone();
    new_image->Reset();
    
    vector3 new_elems;
    h2v_get_elements( new_image, &new_elems );
    
    auto iteration = (int)mlem_image.size();
    new_image->SetName( Form( "mlem_image_iter%03d", iteration) );

    // return new_image;
    
    // cout << "get_element from previous" << endl;
    // vector3 prev_elems = new_elems;
    vector3 prev_elems;//define_vector( nbinsx, nbinsy, nbinsz );
    h2v_get_elements( previous_image, &prev_elems );
    
    vector3 temp_elems, temp2_elems;
    // cout << "begin while" << endl;

    long current_entry = -1;
    event.init_entry();
    
    while ( event.next() ) {
	
	++current_entry;

	// cout << "get_elements from event" << endl;
	// h2v_get_elements( (TH3F*)event.response->Clone(), &temp_elems );
	h2v_get_elements( event.response, &temp_elems );

	//cout << "copy_elements" << endl;
	//v2v_copy_elements( temp_elems, &temp2_elems );
	temp2_elems = temp_elems;

	// continue;

	// cout << "multiply_elements" << endl;
	v2v_multiply_elements( prev_elems, &temp_elems );
	//auto multiple = (TH3F*)event.response->Clone();
	//multiple->Multiply( previous_image );

	//cout << "get_integral" << endl;
	auto integral = get_integral( temp_elems );
	// auto integral = multiple->Integral();
	// vector_integral_of_multiple.emplace_back( integral );

	//cout << "scale_elements" << endl;
	scale_elements( vector_integral_of_response[ current_entry ] /
			( integral + denominator_offset ), &temp2_elems );

	// auto tempo = (TH3F*)event.response->Clone();
	// tempo->Scale( vector_integral_of_response[ current_entry ] /
	// 	      ( integral + denominator_offset ) );
	
	// new_image->Add( tempo );
	// cout << "add_elements" << endl;

	// v2h_add_elements( temp2_elems, new_image );
	v2v_add_elements( temp2_elems, &new_elems );
	 
	// multiple->Delete();
	// tempo->Delete();	
    }

    temp_elems.clear();
    temp_elems.shrink_to_fit();
    temp2_elems.clear();
    temp2_elems.shrink_to_fit();
    
    //cout << "end while" << endl;

    auto diff_new_and_previous = (TH3F*)previous_image->Clone();
    diff_new_and_previous->SetName( Form( "diff_image_prev_and_iter%03d", iteration) );
    diff_new_and_previous->Reset();
    v2h_set_elements( new_elems, diff_new_and_previous );
    diff_image.emplace_back( diff_new_and_previous );
    
    //cout << "multipy" << endl;
    v2v_multiply_elements( prev_elems, &new_elems );
    
    //cout << "set to new_image" << endl;
    if ( this->is_enabled_use_sbp_as_efficiency ) {
	vector3 sbp_elems;
	h2v_get_elements( sbp_image, &sbp_elems );	
	v2v_divide_elements( sbp_elems, &new_elems );
    }
    
    v2h_set_elements( new_elems, new_image );
    // new_image->( previous_image );

    new_elems.clear();
    new_elems.shrink_to_fit();
    prev_elems.clear();
    prev_elems.shrink_to_fit();
    // new_image->Multiply( previous_image );
    
    // if ( this->is_enabled_use_sbp_as_efficiency ) 
    // 	new_image->Divide( this->sbp_image );	
    
    return new_image;
}



std::vector<TH2D*> IterateCone3D::TH3Slicer::Slice(TH3F* th3)
{
    std::vector<TH2D*> list_of_slices;
    if ( !th3 ) return list_of_slices;    

    TH2D * frame = define_slice(th3);
    TString hname = th3->GetName();

    std::map<int, TAxis*> axis;
    axis[0] = th3->GetXaxis();
    axis[1] = th3->GetYaxis();
    axis[2] = th3->GetZaxis();

    int slice_axis = 2;
    int xaxis = (slice_axis+1)%3;
    int yaxis = (slice_axis+2)%3;

    auto nbinsx = axis[xaxis]->GetNbins();
    auto nbinsy = axis[yaxis]->GetNbins();
    auto nbinsz = axis[slice_axis]->GetNbins();
    
    for ( int islice=1; islice<nbinsz+1; ++islice ) {

	auto slice = (TH2D*)frame->Clone();
	auto slicez = axis[slice_axis]->GetBinCenter( islice );
	
	TString sname = Form( hname+"_slice_%04d", islice );
	TString title = Form( "slice of "+hname+" at %.3f", slicez );
	slice->SetNameTitle( sname, title );	
	
	for ( int ix=1; ix<nbinsx+1; ix++ ) {
	    
	    for ( int iy=1; iy<nbinsy+1; iy++ ) {
		
		auto content = th3->GetBinContent( ix, iy, islice );		
		slice->SetBinContent( ix, iy, content );
		
	    }
	}
	list_of_slices.emplace_back( slice );
    }
    
    return list_of_slices;
}

TH2D* IterateCone3D::TH3Slicer::define_slice(TH3F* th3, int slice_axis)
{
    // auto xaxis = th3->GetXaxis();
    // auto yaxis = th3->GetYaxis();
    // auto zaxis = th3->GetZaxis();

    std::map<int, TAxis*> axis;
    axis[0] = th3->GetXaxis();
    axis[1] = th3->GetYaxis();
    axis[2] = th3->GetZaxis();

    std::vector<double> axis_min;
    std::vector<double> axis_max;
    std::vector<int> axis_nbins;    
    
    for ( int i=1; i<3; ++i ) {
	int iaxis = (slice_axis+i)%3;
	axis_min.emplace_back( axis[iaxis]->GetXmin() );
	axis_max.emplace_back( axis[iaxis]->GetXmax() );
	axis_nbins.emplace_back( axis[iaxis]->GetNbins() );
    }

    TString hname = (TString)th3->GetName()+"_slice_frame";
    auto h2 = new TH2D( hname, hname,
			axis_nbins[0], axis_min[0], axis_max[0],
			axis_nbins[1], axis_min[1], axis_max[1] );

    return h2;
}

