/**
   @file   PETimager.cpp
   @date   2020/06/10
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "PETimager.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

PETimager::PETimager()
    : anl::VANL_Module("PETimager", "0.1"), cc1(nullptr), cc2(nullptr)
{
    window = 5;
    ecut_bgn = 450;
    ecut_end = 550;

    define_parameter<std::string>("input_file1", "input1.root");
    define_parameter<std::string>("input_file2", "input2.root");
    define_parameter<std::string>("output_file", "out.root");
    define_parameter<int>("time_window_clk", window);
    define_parameter<int>("number_of_events", -1);
    define_parameter<double>("e_window_begin", ecut_bgn);
    define_parameter<double>("e_window_end", ecut_end);
    define_parameter<double>("rotation_about_vertical_deg", 0.0);
    define_parameter<double>("detector_z_position", 41.35);

    define_parameter<int>("nbins_xaxis", 50);
    define_parameter<int>("nbins_yaxis", 30);
    define_parameter<int>("nbins_zaxis", 50);
    define_parameter<double>("minimum_xaxis", -5.0);
    define_parameter<double>("maximum_xaxis", 5.0);
    define_parameter<double>("minimum_yaxis", -3.0);
    define_parameter<double>("maximum_yaxis", 3.0);
    define_parameter<double>("minimum_zaxis", -5.0);
    define_parameter<double>("maximum_zaxis", 5.0);
}
PETimager::~PETimager()
{
}

int PETimager::mod_bgnrun()
{
    auto infile1 = get_parameter<std::string>("input_file1");
    auto infile2 = get_parameter<std::string>("input_file2");
    cc1 = new pet::hittree_reader( infile1.c_str() );
    cc2 = new pet::hittree_reader( infile2.c_str() );
    
    auto outname = get_parameter<std::string>("output_file");
    outfile = new TFile( outname.c_str(), "recreate" );
    if ( !outfile || outfile->IsZombie() ) return anl::ANL_NG;
    
    static const int nbins = 50;
    //static const int nbins = 320;
    static const double xmax = 5;
    static const double xmin = -xmax;

    auto nbins_xaxis = get_parameter<int>("nbins_xaxis");
    auto nbins_yaxis = get_parameter<int>("nbins_yaxis");
    auto nbins_zaxis = get_parameter<int>("nbins_zaxis");
    auto minimum_xaxis = get_parameter<double>("minimum_xaxis");
    auto maximum_xaxis = get_parameter<double>("maximum_xaxis");
    auto minimum_yaxis = get_parameter<double>("minimum_yaxis");
    auto maximum_yaxis = get_parameter<double>("maximum_yaxis");
    auto minimum_zaxis = get_parameter<double>("minimum_zaxis");
    auto maximum_zaxis = get_parameter<double>("maximum_zaxis");

    image = new TH3F( "image", "image;X(mm);Y(mm);Z(mm)",
		      nbins_xaxis, minimum_xaxis, maximum_xaxis, nbins_yaxis, minimum_yaxis, maximum_yaxis, nbins_zaxis, minimum_zaxis, maximum_zaxis );
    
    image2d = new TH2D( "image2d", "image2d;X(mm);Y(mm)",
			nbins, xmin, xmax, nbins, xmin, xmax );
    
    image2d_ecut = new TH2D( "image2d_ecut", "image2d_ecut;X(mm);Y(mm)",
			     nbins, xmin, xmax, nbins, xmin, xmax );
    
    spect = new TH1D( "spect", "spect", 1500, -0.5, 1499.5 );
    
    spect2d = new TH2D( "spect2d", "spect2d;Etot on CC1;Etot on CC2", 1000, -0.5, 999.5, 1000, -0.5, 999.5 );
    
    hist_deltat = new TH1D( "hist_deltat", "deltat=t1-t2;1clk=50ns", 201, -100.5, 100.5 );
    
    window = get_parameter<int>("time_window_clk");
    if ( window<=0 ) return anl::ANL_NG;
    
    ecut_bgn = get_parameter<double>("e_window_begin");
    ecut_end = get_parameter<double>("e_window_end");    
    if ( ecut_end <= ecut_bgn ) return anl::ANL_NG;

    auto rotate_deg = get_parameter<double>("rotation_about_vertical_deg");
    rotate_vertical = ROOT::Math::RotationY(rotate_deg*TMath::Pi()/180.0);
    convert_cc2 = ROOT::Math::RotationY(TMath::Pi());
    
    detector_z_position = get_parameter<double>("detector_z_position");
    
    return anl::ANL_OK;
}

int PETimager::mod_ana()
{    
    auto nvoxels = image->GetNcells();
    auto npixels = image2d->GetNcells();
    auto nentries = set_reader(cc1, cc2);

    auto number_of_events = get_parameter<int>("number_of_events");
    if ( number_of_events>0 && number_of_events<nentries )
	nentries = number_of_events;
    
    // const double distance_threshold = image->GetXaxis()->GetBinWidth(1)*0.5;
    const double distance_threshold = 0.250/2.35*3;
    
    if ( nentries<0 ) return -1;
    
    //nentries = 10;
    for ( long i=0; i<nentries; ++i ){
	
	if ( i%1000==0 ){
	    std::cout << i << "/" << nentries << "(" << (double)i/nentries*100.0 << "%)" << std::endl;
	}
	
	//cc1->get_entry(i); cc2->get_entry(i);
	if ( !cc1->next() || !cc2->next() ) break;
	
	hist_deltat->Fill( int(cc1->msec_counter-cc2->msec_counter) );
	
	int coin = is_coincidence(cc1, cc2);
	if ( coin == 0 ) continue;
	if ( coin!= 1 ) {
	    while ( coin<0 ) { 
		if ( coin == -1 ) cc1->next();
		else if ( coin == -2 ) cc2->next();			
		coin = is_coincidence(cc1, cc2);
	    }
	}
	
	// print_branch(cc1, cc2);
	
	//if ( !is_coincidence(cc1, cc2) ) continue;
	if ( cc1->nhit_lv3==0 || cc1->nhit_lv3==0 )  continue;	
			
	int index_1st_cc1 = cc1->nhit_lv3 - 1;
	int index_1st_cc2 = cc2->nhit_lv3 - 1;
	
	double e_cc1 = total_energy(cc1);
	double e_cc2 = total_energy(cc2);
	
	spect->Fill(e_cc1+e_cc2);
	spect2d->Fill( e_cc1, e_cc2 );
	
	auto p1 = ROOT::Math::XYZPoint( cc1->pos_x_lv3[index_1st_cc1],
					cc1->pos_y_lv3[index_1st_cc1],
					cc1->pos_z_lv3[index_1st_cc1] - detector_z_position );
	auto p2 = ROOT::Math::XYZPoint( cc2->pos_x_lv3[index_1st_cc2],
					cc2->pos_y_lv3[index_1st_cc2],
					cc2->pos_z_lv3[index_1st_cc2] - detector_z_position );

	// auto p2 = ROOT::Math::XYZPoint( -1*cc2->pos_x_lv3[index_1st_cc2],
	// 				cc2->pos_y_lv3[index_1st_cc2],
	// 				-1*cc2->pos_z_lv3[index_1st_cc2] + detector_z_position );

	//auto p2_org = p2;
	p1 = rotate_vertical( p1 );
	p2 = rotate_vertical( p2 );
	p2 = convert_cc2( p2 );	

	// print_xyz(p1, "p1");
	// print_xyz(p2_org, "p2_org");
	// print_xyz(p2, "p2_rot");
	
	// auto p20r = rotate_vertical(p20);
	// auto p202 = convert_cc2( p20 );
	// //auto p12 = hit_position( cc1, index_1st_cc1 );
	// auto p22 = hit_position( cc2, index_1st_cc2 );
	// auto p23 = convert_cc2( hit_position( cc2, index_1st_cc2 ) );

	// //print_xyz(p12, "p12");
	// cout << endl;
	// print_xyz(p20, "p20");
	// print_xyz(p20r, "p20r");
	// print_xyz(p202, "p202");
	// print_xyz(p2, "p21");
	// print_xyz(p22, "p22");
	// print_xyz(p23, "p23");
		
	
	
	pet::line3d l(p1, p2);
	
	for ( int voxel=0; voxel<nvoxels; ++voxel ){
	    //break;
	    if ( image->IsBinOverflow(voxel) || image->IsBinUnderflow(voxel) )
		continue;
	    
	    auto pos_voxel = xyz_point(image, voxel);		    
	    auto distance = l.distance(pos_voxel);
	    
	    if( distance<=distance_threshold ){			
		auto content = image->GetBinContent(voxel);
		//content += 1.0/(distance*distance+1.0);
		content += exp(-1.0*distance*distance);
		image->SetBinContent(voxel, content);
	    }
	}
	
	for ( int pixel=0; pixel<npixels; ++pixel ){
	    if ( image2d->IsBinOverflow(pixel) || image2d->IsBinUnderflow(pixel) )
		continue;
	    
	    auto pos_pixel = xyz_point(image2d, pixel, 0);
	    auto distance = l.distance(pos_pixel);
	    
	    if( distance<=distance_threshold ){			
		auto content = image2d->GetBinContent(pixel);
		//content += 1.0/(distance*distance+1.0);
		content += line_spread(distance);
		image2d->SetBinContent(pixel, content);
		
		if ( ecut_bgn <= e_cc1 && e_cc1 <= ecut_end && ecut_bgn <= e_cc2 && e_cc2 <= ecut_end )
		    image2d_ecut->SetBinContent(pixel, content);
	    }
	}
	
	
	
    }

    return anl::ANL_OK;
}

int PETimager::mod_endrun()
{
    if ( !outfile || !image || !outfile->IsOpen() ) return -1;

    outfile->cd();
    
    image2d->Write();
    image2d_ecut->Write();
    image->Write();
    
    spect->Write();
    spect2d->Write();
    
    hist_deltat->Write();
    
    outfile->Close();

    return anl::ANL_OK;
}

ROOT::Math::XYZPoint PETimager::hit_position
(pet::hittree_reader* cc, int index)
{
    auto x = cc1->pos_x_lv3[index];
    auto y = cc1->pos_y_lv3[index];
    auto z = cc1->pos_z_lv3[index] - detector_z_position;
    
    auto r = rotate_vertical( ROOT::Math::XYZPoint( x, y, z ) );
    return r;
}
