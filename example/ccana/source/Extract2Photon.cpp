/**
   @file   Extract2Photon.cpp
   @date   2020/05/06
   @author goroyabu
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "Extract2Photon.hpp"

#include <vector>
#include <string>

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <TROOT.h>
#include <TFile.h>
#include <TTree.h>
#include <TString.h>
#include <TEventList.h>
#include <TH1D.h>
#include <TCut.h>
#include <TChain.h>

#include <bnk.hpp>
#include <evs.hpp>

Extract2Photon::Extract2Photon()
    : anl::VANL_Module("Extract2Photon", "0.1")
{    
    define_parameter<std::string>("input_file1", "input1.root");
    define_parameter<std::string>("input_file2", "input2.root");
    define_parameter<std::string>("output_file1", "output1.root");
    define_parameter<std::string>("output_file2", "output2.root");
    define_parameter<std::string>("tree_name", "eventtree");
    define_parameter<int>("time_window", 100);
}
Extract2Photon::~Extract2Photon()
{
}

int Extract2Photon::mod_bgnrun()
{
    auto input_file1 = get_parameter<std::string>("input_file1");
    auto input_file2 = get_parameter<std::string>("input_file2");
    auto output_file1 = get_parameter<std::string>("output_file1");
    auto output_file2 = get_parameter<std::string>("output_file2");
    
    // for ( auto filename : { file1, file2 } ){
    // 	auto f = new TFile(filename.c_str());
    // 	if ( !f || f->IsZombie() ){
    // 	    cerr << filename << " is not found." << endl;
    // 	    return -1;
    // 	} else cout << filename << endl;	
    // 	file.emplace_back( f );
    // }
   
    auto treename = get_parameter<std::string>("tree_name");
    
    // for ( auto f : file ) {
    // 	auto t = (TTree*)f->Get( treename.c_str() );
	
    // 	auto e = new eventdata(t);
    // 	event.emplace_back( e );

    // 	auto newname = (TString)f->GetName();
    // 	newname.ReplaceAll(".root", "_extcoin.root");
    // 	copier.emplace_back( new TreeCopier( std::string(newname), e ) );
    // }

    auto file1 = std::make_pair( input_file1, output_file1 );
    auto file2 = std::make_pair( input_file2, output_file2 );
    
    for ( auto [ input, output ] : { file1, file2 } ) {

	auto chain = new TChain( treename.c_str() );
	chain->Add( input.c_str() );

	if ( chain->GetNtrees()==0 ) {
	    cout << treename << " is not found in " << input << endl;
	    return anl::ANL_NG;
	}

    	auto e = new eventdata( chain );
    	event.emplace_back( e );

    	//auto newname = (TString)filename;
    	//newname.ReplaceAll(".root", "_extcoin.root");
    	//copier.emplace_back( new TreeCopier( std::string(newname), e ) );
	copier.emplace_back( new TreeCopier( std::string(output), e ) );	
    }
    
    multitree = MultiTreeReader(event);
    // hist = new TH1D("h_delta_msec", ";#Delta_msec_counter", 200, -100, 100);

    // const int window = cmdline::get_option<int>("window");
    // auto window = get_parameter<int>("time_window");
    
    return anl::ANL_OK;
}

int Extract2Photon::mod_ana()
{
    auto window = get_parameter<int>("time_window");
    long n_coincidence = 0;
    
    while( multitree.NextCoin(window) ){

	auto delta_t = (int)(event[0]->msec_counter-event[1]->msec_counter);

	for ( auto cp : copier ) cp->Fill(delta_t);       

	++n_coincidence;
    }
    
    cout << "Total Coincidence=" << n_coincidence << endl;
    
    //return anl::ANL_OK;

    for ( auto cp : copier ) cp->Close();
    for ( auto f : file ) f->Close();

    return anl::ANL_LOOP;
}

int Extract2Photon::mod_endrun()
{
    // for ( auto cp : copier ) cp->Close();
    // for ( auto f : file ) f->Close();
    return anl::ANL_OK;
}

Extract2Photon::eventdata::eventdata(TTree* tree)
    : tree(tree)
{
    entry = -1;
    nentries = tree->GetEntries();
    selected_entry = -1;
    selected_nentries = 0;

    if ( !tree->FindBranch("gps1pps") ) {
	/* Old data format */
	gps1pps = 0;
	ext1pps = 0;
	tree->SetBranchAddress("ext1pps", &ext1pps_uint);
	tree->SetBranchAddress("msec_counter", &msec_counter);
	tcut_format = "%d<=ext1pps && ext1pps<=%d";
    }
    else {
	tree->SetBranchAddress("gps1pps", &gps1pps);
	tree->SetBranchAddress("ext1pps", &ext1pps);
	ext1pps_uint = 0;
	tree->SetBranchAddress("msec_counter", &msec_counter);
	tcut_format = "%d<=gps1pps*65536+ext1pps && gps1pps*65536+ext1pps<=%d";
    }
    
    tree->GetEntry(0);
}
bool Extract2Photon::eventdata::GetEntry(long i)
{
    if(i<0){ entry = i;  return false; }
    
    else if(i>=nentries) return false;
    
    entry = i; selected_entry = i;
    tree->GetEntry(i);
    
    return true;
}
long Extract2Photon::eventdata::GetSelectedEntries() const
{
    return tree->GetEventList()->GetN();
}
bool Extract2Photon::eventdata::GetSelectedEntry(long i)
{
    if(!tree->GetEventList()) return false;
    
    else if(i<0){ selected_entry = -1;  return false; }
    
    else if(i>=GetSelectedEntries()) return false;
    
    entry = tree->GetEventList()->GetEntry(i);
    selected_entry = i;
    tree->GetEntry( entry );
    
    return true;
}
bool Extract2Photon::eventdata::NextSelectedEntry()
{
    return this->GetSelectedEntry(this->selected_entry+1);
}
TCut Extract2Photon::eventdata::CutOverlap(std::vector<eventdata*> event)
{
    if ( event.size()==0 ) return "";
    
    for(auto e : event) e->tree->GetEntry(0);
    auto smallest = -1;
    for(auto e : event){
	if(smallest<0) smallest = e->external_clock();
	else if(smallest>e->external_clock()) smallest = e->external_clock();
    }	
    for(auto e : event) e->GetEntry(e->nentries-1);
    auto biggest = -1;
    for(auto e : event){
	if(biggest<0) biggest = e->external_clock();
	else if(biggest<e->external_clock()) biggest = e->external_clock();
    }
    // return Form("%d<=gps1pps*65536+ext1pps && gps1pps*65536+ext1pps<=%d", smallest, biggest);
    return Form( event[0]->tcut_format, smallest, biggest );
}

Extract2Photon::TreeCopier::TreeCopier()
    : outfile(nullptr), outtree(nullptr), indata(nullptr), hist(nullptr)
{
}
Extract2Photon::TreeCopier::TreeCopier(std::string outname, eventdata* event)
{
    outfile = new TFile ( outname.c_str(), "recreate" );
    if ( !outfile || !event || outfile->IsZombie() ) {
	std::cerr << "Opening " << outname << " is failed." << std::endl;
	outfile = nullptr; outtree = nullptr; indata = nullptr; hist = nullptr;
    } else {
	cout << outname << " is created." << endl;

	TString hname = "h_"+((TString)outname)
	    .ReplaceAll("/","_").ReplaceAll(".","_");
	hist = new TH1D( hname, ";#Delta_msec_counter", 200, -100, 100);
	// cout << hist->GetName() << " is created." << endl;
	// outfile->Add( hist );
     	
	indata = event;
	outtree = indata->tree->CloneTree( 0 );
	outtree->Branch( "coin_ext_timeid", &m_coin_ext_timeid,
			 "coin_ext_timeid/L");
	outtree->Branch( "coin_int_timeid", &m_coin_int_timeid,
			 "coin_int_timeid/L");
	// outfile->Add( outtree );
    }

}
Extract2Photon::TreeCopier::~TreeCopier()
{
    if ( !!outfile && outfile->IsOpen() ) this->Close();
}
int Extract2Photon::TreeCopier::Fill(int delta_t)
{
    if ( !outtree ) return -1;
    m_coin_ext_timeid = indata->external_clock();
    m_coin_int_timeid = indata->msec_counter;
    hist->Fill( delta_t );
    outtree->Fill(); return 0;
}
int Extract2Photon::TreeCopier::Close()
{
    if ( !outfile || !outfile->IsOpen() || !outtree ) return -1;
    // cout << "Closing " << outfile->GetName() << "..." << endl;
    outfile->cd();
    //outfile->ls();
    //outfile->Add(outtree);
    outtree->Write();
    hist->SetName("h_delta_msec");
    // outfile->Add(hist);
    hist->Write();
    // outfile->Write();
    outfile->Close(); return 0;
}


Extract2Photon::MultiTreeReader::MultiTreeReader(std::vector<eventdata*> event)
    : m_event(event)
{
    this->initialize();
}
int Extract2Photon::MultiTreeReader::initialize()
{
    auto cut_overlap = eventdata::CutOverlap(m_event);
    std::cout << cut_overlap << std::endl;
    
    for(int ie=0; ie<(int)m_event.size(); ++ie){
	auto name = Form("evlist_%04d",ie);
	m_event[ie]->tree->Draw((TString)">>"+name, cut_overlap);
	TEventList *elist = (TEventList*)gDirectory->Get(name);
	m_event[ie]->tree->SetEventList(elist);
    }
    
    for(auto e : m_event) e->GetSelectedEntry(-1);
    
    return 0;
}
bool Extract2Photon::MultiTreeReader::next_entry(std::vector<eventdata*>& event)
{
    for(auto e : event)
	if(!e->NextSelectedEntry()) return false;
    return true;
}
bool Extract2Photon::MultiTreeReader::NextCoin(const int window)
{
    //const int window = 100;
    while( true ){
	if( !next_entry(m_event) ) return false;
	
	if(m_event[0]->GetSelectedCurrentEntry()%100000==0){
	    std::cout << m_event[0]->GetSelectedCurrentEntry() << " / ";
	    std::cout << m_event[0]->GetSelectedEntries() << "(";
	    std::cout << (double)m_event[0]->GetSelectedCurrentEntry()/m_event[0]->GetSelectedEntries()*100.0 << "%)" << std::endl;
	}
	
	auto gap_of_external_time_id = m_event[0]->time_id() - m_event[1]->time_id();
	
	if     ( gap_of_external_time_id < 0 ) {
	    m_event[0]->NextSelectedEntry();  continue;
	}
	else if( gap_of_external_time_id > 0 ) {
	    m_event[1]->NextSelectedEntry();  continue;
	}
	else {
	    
	    auto gap_of_internal_time_id
		= (int)(m_event[0]->msec_counter - m_event[1]->msec_counter);
	    
	    if( std::abs(gap_of_internal_time_id)<=window ) return true;
	    
	    if     ( gap_of_internal_time_id < 0 ) {
		m_event[0]->NextSelectedEntry();  continue;
	    }
	    else if( gap_of_internal_time_id > 0 ) {
		m_event[1]->NextSelectedEntry();  continue;
	    }
	    else {
		m_event[0]->NextSelectedEntry();
		m_event[1]->NextSelectedEntry();
		continue;
	    }
	    
	}
	
    }
    return false;
}


// int show_coin()
// {
//     using std::cout;
//     using std::endl;
    
//     auto filelist = gROOT->GetListOfFiles();
//     if(!filelist) return -1;
    
//     int nfile = filelist->GetSize();
//     if(nfile<2){
// 	cout << "usage: root CC1DATA.root CC2DATA.root show_coin.C" << endl;
// 	return -1;
//     }
    
//     std::vector<TFile*> file;
//     for(int ifile=0; ifile<nfile; ++ifile){
// 	file.emplace_back((TFile*)filelist->At(ifile));
//     }
    
//     const TString treename = "eventtree";
//     std::vector<eventdata*> event;
//     for(auto f : file){
// 	auto t = (TTree*)f->Get(treename);
// 	event.emplace_back( new eventdata(t) );
//     }
    
//     auto multitree = MultiTreeReader(event);
//     auto h = new TH1D("h_delta_msec", ";#Delta_msec_counter", 200, -100, 100);
    
//     while( multitree.NextCoin() ){
// 	auto delta_t = (int)(event[0]->msec_counter-event[1]->msec_counter);
// 	h->Fill(delta_t);
//     }
    
//     cout << "Total Coincidence=" << h->GetEntries() << endl;
//     h->Draw();
    
//     return 0;
// }

// void define_args()
// {
//     cmdline::add_option<int>("window", 'w', "time window of coincidence", false, 100);
//     cmdline::set_program_name("coin_dualcc");
//     cmdline::set_args_name("FILE1 FILE2");
// }

// int main(int argc, char* argv[])
// {
//     using std::cout;
//     using std::endl;
//     using std::cerr;
    
//     define_args();
    
//     cmdline::parse_check(argc, argv);
//     auto args = cmdline::get_args();
    
//     if ( (int)args.size()!=2 ) return cmdline::print_usage();

    
        
//     return 0;
// }
