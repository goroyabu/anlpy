/**
   @file   PETimager.hpp
   @date   2020/06/10
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#ifndef PETimager_hpp
#define PETimager_hpp

#include <VANL_Module.hpp>

#include <cstdlib>
#include <iostream>
#include <complex>
#include <cmath>

#include <Math/Vector3Dfwd.h>
#include <Math/Point3Dfwd.h>
#include <Math/Plane3D.h>
#include <Math/RotationY.h>

#include <TSystem.h>
#include <TMath.h>
#include <TFile.h>
#include <TTree.h>
#include <TH3F.h>
#include <TH2D.h>
#include <TH1D.h>

namespace pet
{

    class hittree_reader
    {
    public:
	
	TTree* tree;
	long int current_entry;
	long int nentries;
	unsigned short int gps1pps, ext1pps;
	unsigned int msec_counter;
	int nhit_lv3;
	std::vector<int> detid_lv3;
	std::vector<float> epi_lv3;
	std::vector<float> pos_x_lv3, pos_y_lv3, pos_z_lv3;	

    private:

	TTree* get_tree(TString filename, TString treename)
	{
	    if ( gSystem->AccessPathName(filename) ){
		std::cout << filename << " is not found." << std::endl;
		return nullptr;
	    }
	    auto f = new TFile(filename);
	    if ( !f || f->IsZombie() ){
		std::cout << "Opening " << filename << " is failed." << std::endl;
		return nullptr;
	    }	    
	    auto t = (TTree*)f->Get(treename);
	    if ( !t ){
		std::cout << treename << " is not found in " << filename << "." << std::endl;
		return nullptr;
	    }
	    return t;
	}
	
	template<typename T>
	static int set_branch_address(TTree* tree, TString key, T* ptr)
	{
	    if( !tree->FindBranch(key) ) return -1;
	    tree->SetBranchAddress( key, ptr );
	    return 0;
	}

	template<typename T>
	static int set_branch_address(TTree* tree, TString key, std::vector<T>* vec)
	{
	    if( !tree->FindBranch(key) ) return -1;
	    vec->resize(64);
	    tree->SetBranchAddress( key, vec->data() );
	    return 0;
	}
	
	int set_branch_address(TTree* tree)
	{
	    if( !tree ) return -1;
	    this->tree = tree;
	    set_branch_address( tree,  "gps1pps",       &gps1pps       );
	    set_branch_address( tree,  "ext1pps",       &ext1pps       );
	    set_branch_address( tree,  "msec_counter",  &msec_counter  );
	    set_branch_address( tree,  "nhit_lv3",      &nhit_lv3      );
	    set_branch_address( tree,  "detid_lv3",     &detid_lv3     );
	    set_branch_address( tree,  "epi_lv3",       &epi_lv3       );
	    set_branch_address( tree,  "pos_x_lv3",     &pos_x_lv3     );
	    set_branch_address( tree,  "pos_y_lv3",     &pos_y_lv3     );
	    set_branch_address( tree,  "pos_z_lv3",     &pos_z_lv3     );
	    nentries = tree->GetEntries();
	    return 0;
	}
	
    public:
	
	hittree_reader(TString filename, TString treename="hittree")
	{
	    auto tree = get_tree(filename, treename);
	    set_branch_address(tree);
	    current_entry = -1;
	}

	~hittree_reader()
	{
	}

	int get_entry(long i)
	{
	    if ( !tree ) return -1;
	    tree->GetEntry(i); return 0;
	}
	bool next()
	{
	    if ( !tree ) return false;
	    if ( current_entry-1 >= nentries ) return false;
	    ++current_entry;
	    tree->GetEntry( current_entry );
	    return true;
	}
	
    };
    
    struct line3d
    {
	// l = a + t*v where t is parameter.
	ROOT::Math::XYZPoint a;
	ROOT::Math::XYZVector v;
	
	line3d(const ROOT::Math::XYZPoint& p1, const ROOT::Math::XYZPoint& p2)
	{
	    a = p1;
	    v = p2 - p1;
	}

	ROOT::Math::XYZPoint ortho_cross(const ROOT::Math::XYZPoint& p3)
	{
	    double t = v.Dot(p3-a)/v.Mag2();
	    return a + t*v;
	}
	
	double distance(const ROOT::Math::XYZPoint& p3)
	{
	    auto c = ortho_cross(p3);
	    return sqrt( (c-p3).Mag2() );
	}
	
    };
}

class PETimager : public anl::VANL_Module
{
private:
    pet::hittree_reader * cc1;
    pet::hittree_reader * cc2;
    TFile * outfile;
    
    int window;
    double ecut_bgn;
    double ecut_end;
    //double rotation_about_vertical_deg;
    ROOT::Math::RotationY rotate_vertical;
    ROOT::Math::RotationY convert_cc2;
    double detector_z_position;    
    
public:
    TH3F * image;
    TH2D * image2d;
    TH2D * image2d_ecut;
    
    TH1D * spect;
    TH2D * spect2d;
    
    TH1D * hist_deltat;
    
public:
    PETimager();
    ~PETimager();

    int mod_bgnrun() override;
    int mod_ana() override;
    int mod_endrun() override;

    int is_coincidence(pet::hittree_reader* cc1, pet::hittree_reader* cc2)
    {	    
	auto time1 = cc1->gps1pps*65536+cc1->ext1pps;
	auto time2 = cc2->gps1pps*65536+cc2->ext1pps;
	if ( time1 < time2 ) return -1;
	else if ( time1 > time2 ) return -2;	    
	//const static int window = 5;
	//std::cout << std::abs(int(cc1->msec_counter-cc2->msec_counter)) << "<=" << window << std::endl;
	if ( std::abs( int(cc1->msec_counter-cc2->msec_counter))<=window ) return 1;
	return 0;
    }
    long int set_reader(pet::hittree_reader* cc1, pet::hittree_reader* cc2)
    {
	if ( !cc1 || !cc2 || !cc1->tree || !cc2->tree ) return -1;
	long nentries1 = cc1->tree->GetEntries();
	long nentries2 = cc2->tree->GetEntries();
	//if ( abs(nentries1-nentries2)>10 ) return -1;
	if ( nentries1 < nentries2 ) return nentries1;
	else if ( nentries1 > nentries2 ) return nentries2;
	return nentries1;
    }
    int print_branch(pet::hittree_reader* cc1, pet::hittree_reader* cc2)
    {
	using std::cout;
	using std::endl;
	if( cc1->nhit_lv3<1 || cc2->nhit_lv3<1 ){
	    cout << "--" << endl;
	    cout << "nhit=0" << endl;
	    cout << "--" << endl;
	    return 0;
	}
	cout << "--" << endl;
	cout << "x: " << cc1->pos_x_lv3[0] << " " << cc2->pos_x_lv3[0] << endl;
	cout << "y: " << cc1->pos_y_lv3[0] << " " << cc2->pos_y_lv3[0] << endl;
	cout << "z: " << cc1->pos_z_lv3[0] << " " << cc2->pos_z_lv3[0] << endl;
	cout << "--" << endl;
	return 0;
    }
    void print_xyz(const ROOT::Math::XYZPoint& p, std::string name)
    {
	using std::cout;
	using std::endl;
	cout << name << "=" << p.x() << ", " << p.y() << ", " << p.z() << endl;
    }
    ROOT::Math::XYZPoint xyz_point(TH3* th3, const int global_bin)
    {
	int binx, biny, binz;
	th3->GetBinXYZ(global_bin, binx, biny, binz);
	
	float x = th3->GetXaxis()->GetBinCenter(binx);
	float y = th3->GetYaxis()->GetBinCenter(biny);
	float z = th3->GetZaxis()->GetBinCenter(binz);
	return ROOT::Math::XYZPoint(x,y,z);
    }
    ROOT::Math::XYZPoint xyz_point(TH2* th2, const int global_bin, const float z)
    {
	int binx, biny, binz;
	th2->GetBinXYZ(global_bin, binx, biny, binz);
	
	float x = th2->GetXaxis()->GetBinCenter(binx);
	float y = th2->GetYaxis()->GetBinCenter(biny);
	return ROOT::Math::XYZPoint(x,y,z);
    }
    double total_energy(pet::hittree_reader* cc)
    {
	double e = 0.0;
	int nhit = cc->nhit_lv3;
	for ( int i=0; i<nhit; ++i) e += cc->epi_lv3[i];
	return e;
    }
    double line_spread(double d)
    {
	const static double sigma = 0.250/2.35;
	const static double a = 1 / std::sqrt(2*3.14) / sigma;
	const static double c = -0.5 / sigma / sigma;	    
	return a * std::exp( c * d * d );
    }

    ROOT::Math::XYZPoint hit_position
    (pet::hittree_reader* cc, int index);
    
};

#endif

