/**
   @file   Iterate2Photon3D.cpp
   @date   2020/05/18
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "Iterate2Photon3D.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

#include <TH3F.h>

Iterate2Photon3D::Iterate2Photon3D()
    : anl::VANL_Module("Iterate2Photon3D", "0.1")
{
    define_parameter<std::string>("input_file1", "input1.root");
    define_parameter<std::string>("input_tree1", "resptree1");
    // define_parameter<std::string>("input_file2", "input2.root");
    define_parameter<std::string>("input_tree2", "resptree2");    
    define_parameter<std::string>("output_file", "output.root");
    define_parameter<int>("n_of_iterations", 0);
    // define_parameter<int>("number_of_events", -1);
    define_parameter<int>("eventid", -1);
}
Iterate2Photon3D::~Iterate2Photon3D()
{
}

int Iterate2Photon3D::mod_bgnrun()
{
    auto input_tree1 = get_ttree( "input_file1", "input_tree1" );
    auto input_tree2 = get_ttree( "input_file1", "input_tree2" );

    if ( !input_tree1 || !input_tree2 ) return anl::ANL_NG;
    
    auto nentries1 = event1.set_branch_address(input_tree1);
    auto nentries2 = event2.set_branch_address(input_tree2);

    cout << "# of entries in " << input_tree1->GetName() << " = " << nentries1 << endl;
    cout << "# of entries in " << input_tree2->GetName() << " = " << nentries2 << endl;

    output_file = recreate_tfile( "output_file" );
    if ( !output_file ) return anl::ANL_NG;
    
    sbp_image = (TH3F*)event1.response->Clone();
    sbp_image->Reset();
    sbp_image->SetName("sbp_image");

    //number_of_events = get_parameter<int>("number_of_events");
    eventid = get_parameter<int>("eventid");
    current_entry = -1;
    
    return anl::ANL_OK;
}

int Iterate2Photon3D::mod_ana()
{
    // if ( 0<number_of_events && current_entry<=number_of_events )
    // 	return anl::ANL_LOOP;
	    
    if ( !event1.next() ) return anl::ANL_LOOP;
    if ( !event2.next() ) return anl::ANL_LOOP;

    ++current_entry;

    if ( eventid!=-1 && eventid>current_entry )
	return anl::ANL_SKIP;
    if ( eventid!=-1 && eventid<current_entry )
	return anl::ANL_LOOP;
    
    auto h1 = (TH3F*)event1.response->Clone();
    auto h2 = (TH3F*)event2.response->Clone();
    h1->Multiply( h2 );
    
    sbp_image->Add( h1 );
    
    return anl::ANL_OK;
}

int Iterate2Photon3D::mod_endrun()
{
    output_file->cd();
    
    auto slice = IterateCone3D::TH3Slicer::Slice(sbp_image);
    sbp_image->Write();
    for ( auto itr : slice ) itr->Write();

    output_file->Close();
    // input_file->Close();
    
    return anl::ANL_OK;
}

TFile * Iterate2Photon3D::open_tfile(const std::string& key_of_file)
{
    auto file_name = get_parameter<std::string>( key_of_file );
    auto file = new TFile( file_name.c_str() );
    if ( !file || file->IsZombie() ) {
        cout << "Opening " << file_name << " is failed." << endl;
        return nullptr;
    }
    cout << file_name << " is opened." << endl;
    return file;
}
TTree * Iterate2Photon3D::get_ttree
(const std::string& key_of_file, const std::string& key_of_tree)
{
    auto file = open_tfile( key_of_file );
    if ( !file ) return nullptr;

    auto tree_name = get_parameter<std::string>( key_of_tree );
    auto tree = (TTree*)file->Get( tree_name.c_str() );
    if ( !tree ) {
        cout << tree_name << " is not found." << endl;
        return nullptr;
    }
    cout << tree_name << " is loaded." << endl;
    return tree;
}
TFile * Iterate2Photon3D::recreate_tfile(const std::string& key_of_file)
{
    auto file_name = get_parameter<std::string>( key_of_file );
    auto file = new TFile( file_name.c_str(), "recreate" );
    if ( !file || file->IsZombie() ) {
        cout << "Creating " << file_name << " is failed." << endl;
        return nullptr;
    }
    cout << file_name << " is created." << endl;
    return file;
}
