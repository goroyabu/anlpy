/**
   @file   ProjectCone3D.cpp
   @date   2020/05/07
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "ProjectCone3D.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>


ProjectCone3D::ProjectCone3D()
    : anl::VANL_Module("ProjectCone3D", "0.1"),
      input_file(nullptr), input_tree(nullptr),
      output_file(nullptr), output_tree(nullptr),
      image(nullptr)
{
    define_parameter<std::string>("input_file", "input.root");
    define_parameter<std::string>("input_tree", "hittree");
    define_parameter<std::string>("output_file", "output.root");
    define_parameter<std::string>("output_tree", "resptree");
    define_parameter<double>("e_window_begin", 100.0);
    define_parameter<double>("e_window_end", 300.0);
    define_parameter<double>("cone_thick_deg", 0.5);
    define_parameter<double>("distance_index", 2.0);
    define_parameter<double>("e_threshold_si", 5.0);
    define_parameter<double>("e_threshold_cdte", 5.0);
    define_parameter<int>("nbins_1axis", 100);
    define_parameter<double>("axis_minimum", -25.0);
    define_parameter<double>("axis_maximum", 25.0);
    define_parameter<double>("theta_max_degree", 150.0);
    define_parameter<double>("detector_z_position", -41.0);
}
ProjectCone3D::~ProjectCone3D()
{
}

int ProjectCone3D::mod_bgnrun()
{
    auto nbins = get_parameter<int>("nbins_1axis");
    auto xmin = get_parameter<double>("axis_minimum");
    auto xmax = get_parameter<double>("axis_maximum");
    
    auto ifname = get_parameter<std::string>("input_file");
    input_file = new TFile( ifname.c_str() );
    if ( !input_file || input_file->IsZombie() ) {
	cout << "Opening " << ifname << " is faild." << endl;
	return anl::ANL_NG;
    }
    cout << ifname << " is opened." << endl;

    auto itname = get_parameter<std::string>("input_tree");
    input_tree = (TTree*)input_file->Get( itname.c_str() );
    if ( !input_tree ) {
	cout << itname << " is not found." << endl;
	return anl::ANL_NG;
    }

    event.set_branch_address(input_tree);	
    
    auto ofname = get_parameter<std::string>("output_file");    
    output_file = new TFile( ofname.c_str(), "recreate" );
    if ( !output_file || output_file->IsZombie() ) {
	cout << "Creating " << ofname << " is failed." << endl;
	return anl::ANL_NG;
    }
    cout << ofname << " is created." << endl;

    image = new TH3F( "response", "response;X(mm);Y(mm);Z(mm)",
		      nbins, xmin, xmax, nbins, xmin, xmax, nbins, xmin, xmax );
    
    auto otname = get_parameter<std::string>("output_tree");
    output_tree = new TTree( otname.c_str(), otname.c_str() );
    if ( !output_tree->Branch( "response", "TH3F", &image ) ) {
	cout << "Creating a branch of TH3F is failed." << endl;
	return anl::ANL_NG;
    }

    evs::define("Si-CdTe 2hits event");
    evs::define("SC2hits w/o flour");
    evs::define("SC2hits in E-window");

    e_window_begin = get_parameter<double>("e_window_begin");
    e_window_end = get_parameter<double>("e_window_end");
    cone_thick_rad = get_parameter<double>("cone_thick_deg")*TMath::Pi()/180.0;
    tangent_cone_thick = TMath::Tan( cone_thick_rad/2.35 );
    distance_index_omega = -1.0*get_parameter<double>("distance_index");
    e_threshold_si = get_parameter<double>("e_threshold_si");
    e_threshold_cdte = get_parameter<double>("e_threshold_cdte");
    theta_max_degree = get_parameter<double>("theta_max_degree");
    detector_z_position = get_parameter<double>("detector_z_position");
    
    return anl::ANL_OK;
}

int ProjectCone3D::mod_ana()
{
    if ( !event.next() ) return anl::ANL_LOOP;
    
    auto [ si, cdte ] = get_sc2hit_event();

    if ( si.Energy()<=0.0 || cdte.Energy()<=0.0 ) return anl::ANL_SKIP;

    evs::set("Si-CdTe 2hits event");

    if ( has_flour(si) || has_flour(cdte) ) 
	return anl::ANL_SKIP;    
    
    evs::set("SC2hits w/o flour");
    
    if ( !is_in_energy_range( si.Energy()+cdte.Energy() ) )
	return anl::ANL_SKIP;

    evs::set("SC2hits in E-window");

    if ( !is_in_theta_range( si, cdte ) )
	return anl::ANL_SKIP;    
       
    this->projection( image, si, cdte );
    
    return anl::ANL_OK;
}

int ProjectCone3D::mod_endrun()
{
    output_file->cd();
    output_tree->Write();
    output_file->Close();
    input_file->Close();
    return anl::ANL_OK;
}

int ProjectCone3D::projection(TH3F* image, const hit& si, const hit& cdte)
{
    image->Reset();
    auto nvoxels = image->GetNcells();
    
    auto scat  = si.Postion();
    auto abso  = cdte.Postion();

    auto vec_cone_axis = scat - abso; //fHitPos[0] - fHitPos[1];
    auto scat_angle_deg = eval_theta( si.Energy(), cdte.Energy() );
    //Double_t armrad = armdeg*TMath::Pi()/180.0;
    //fDthetaCompcone = armrad/2.35;
    //fTanDthetaCompcone = TMath::Tan(fDthetaCompcone);

    bool is_filled_voxels = false;
    
    for ( int i=0; i<nvoxels; ++i ) {
	if ( image->IsBinOverflow(i) || image->IsBinUnderflow(i) )
	    continue;
	
	TVector3 voxel = voxel_center(image, i);
	
	auto vec_scat2vox = voxel - scat;
	auto fVecAxisRotateGeneratingline = vec_cone_axis.Cross(vec_scat2vox);
	auto vec_genline_nearest_to_vox = vec_cone_axis;

	if ( fVecAxisRotateGeneratingline.Mag()>=0.0001 ){
	    vec_genline_nearest_to_vox.Rotate(scat_angle_deg, fVecAxisRotateGeneratingline);
	}
	
	//auto fVecGeneratingLineUni = vec_genline_nearest_to_vox.Unit();
	/* The event is rejected if the direction of the generating line
	   is not oriented to the front of the camera. */
	auto scale = vec_scat2vox.Dot( vec_genline_nearest_to_vox.Unit() );
	if( scale<=0.0 ) continue;
	vec_genline_nearest_to_vox *= scale/vec_genline_nearest_to_vox.Mag();

	// if ( vec_scat2vox.Dot( vec_genline_nearest_to_vox.Unit() )<=0 )
	//     continue;	
	
	Double_t mag_vec_nearest_to_vox = vec_genline_nearest_to_vox.Mag();
	Double_t perpen_dist = ( vec_scat2vox - vec_genline_nearest_to_vox ).Mag();
	Double_t sigma = mag_vec_nearest_to_vox*tangent_cone_thick;

	if( perpen_dist>sigma*3 ) continue;
	
	auto weight = TMath::Power( mag_vec_nearest_to_vox, distance_index_omega )
	    *TMath::Exp( -0.5* TMath::Power( perpen_dist/sigma, 2 ) );

	if ( weight<=0 ) continue;
	image->SetBinContent( i, image->GetBinContent(i)+weight );
	is_filled_voxels = true;
	
	//image->Fill( voxel.x, voxel.y, voxel.z, weight );
	//fHistBranch->Fill(voxx,voxy,voxz,weight);	
    }
    if ( is_filled_voxels ) output_tree->Fill();
    
    return 0;
}

std::tuple<ProjectCone3D::hit, ProjectCone3D::hit> ProjectCone3D::get_sc2hit_event()
{
    int n_si = 0; int n_cdte = 0;
    hit si; hit cdte;
    
    for ( int i=0; i<event.nhit_lv3; ++i ) {
	
	if ( is_cdte(event.detid_lv3[i]) && event.epi_y_lv3[i]>=e_threshold_cdte ) {
	    cdte.e = event.epi_y_lv3[i];
	    cdte.x = event.pos_x_lv3[i];
	    cdte.y = event.pos_y_lv3[i];
	    cdte.z = event.pos_z_lv3[i] + detector_z_position;
	    ++n_cdte;
	}
	else if ( is_si(event.detid_lv3[i]) && event.epi_x_lv3[i]>=e_threshold_si ) {
	    si.e = event.epi_x_lv3[i];
	    si.x = event.pos_x_lv3[i];
	    si.y = event.pos_y_lv3[i];
	    si.z = event.pos_z_lv3[i] + detector_z_position;
	    ++n_si;
	}	
    }    
   
    if ( n_si==1 && n_cdte==1 ) return std::make_tuple( si, cdte );
    return std::make_tuple( hit(), hit() );
}

bool ProjectCone3D::hittree_event::exist_branch(TTree* tree, TString key)
{
    if ( !tree->FindBranch(key) ) {
	cout << "TBranch " << key << " is not found." << endl;
	return false;
    }
    return true;
}
int ProjectCone3D::hittree_event::set_branch_address(TTree* tree)
{
    if ( !exist_branch(tree, "nhit_lv3")  ) return anl::ANL_NG;
    if ( !exist_branch(tree, "detid_lv3") ) return anl::ANL_NG;
    if ( !exist_branch(tree, "epi_lv3")   ) return anl::ANL_NG;
    if ( !exist_branch(tree, "epi_x_lv3") ) return anl::ANL_NG;
    if ( !exist_branch(tree, "epi_y_lv3") ) return anl::ANL_NG;
    if ( !exist_branch(tree, "pos_x_lv3") ) return anl::ANL_NG;
    if ( !exist_branch(tree, "pos_y_lv3") ) return anl::ANL_NG;
    if ( !exist_branch(tree, "pos_z_lv3") ) return anl::ANL_NG;

    static const int n = 10;
    detid_lv3.resize(n);
    epi_lv3.resize(n);
    epi_x_lv3.resize(n);
    epi_y_lv3.resize(n);
    pos_x_lv3.resize(n);
    pos_y_lv3.resize(n);
    pos_z_lv3.resize(n);
    
    tree->SetBranchAddress( "nhit_lv3",  &nhit_lv3        );
    tree->SetBranchAddress( "detid_lv3", detid_lv3.data() );
    tree->SetBranchAddress( "epi_lv3",   epi_lv3.data()   );
    tree->SetBranchAddress( "epi_x_lv3", epi_x_lv3.data() );
    tree->SetBranchAddress( "epi_y_lv3", epi_y_lv3.data() );
    tree->SetBranchAddress( "pos_x_lv3", pos_x_lv3.data() );
    tree->SetBranchAddress( "pos_y_lv3", pos_y_lv3.data() );
    tree->SetBranchAddress( "pos_z_lv3", pos_z_lv3.data() );    
    nentries = tree->GetEntries();
    current_entry = -1;
    this->tree = tree;    
    return 0;
}
bool ProjectCone3D::hittree_event::next()
{
    ++current_entry;
    if ( current_entry>=nentries ) return false;
    tree->GetEntry(current_entry);
    return true;
}
