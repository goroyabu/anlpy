/***
    @file   ProjectConeETCC.hpp
    @date
    @author User
    @detail Automatically generated by mkanlproject
***/

#ifndef ProjectConeETCC_hpp
#define ProjectConeETCC_hpp

#include <tuple>

#include <TFile.h>
#include <TTree.h>
#include <TH3F.h>
#include <TMath.h>
#include <TVector3.h>
#include <TF1.h>

#include <VANL_Module.hpp>

class ComptreeEvent
{
    private:
        TTree* tree;
        long nentries;
        long current_entry;

    public:

        int merged_si_nhit;
        std::vector<double> merged_epi_si;

        int n_reconst;
        std::vector<double> epi1;
        std::vector<double> epi2;
        std::vector<double> reconst_epi;
        std::vector<double> cdte_detx;
        std::vector<double> cdte_dety;
        std::vector<double> cdte_detz;
        double epi_total;

        bool reconstructed;
        double init_pos_cmos_detx;
        double init_pos_cmos_dety;
        double init_pos_cmos_detz;
        double phi_cmos_det;

        ComptreeEvent()
            : tree(nullptr)
            {}

        inline bool ExistBranch(TTree* tree, TString key){
            if ( !tree->FindBranch(key) ) {
                std::cout << "TBranch " << key;
                std::cout << " is not found." << std::endl;
                return false;
            }
            return true;
        }
        inline bool ExistBranch(TString key) {
            return ExistBranch( this->tree, key);
        }
        inline bool Next(){
            ++current_entry;
            if ( current_entry>=nentries ) return false;
            tree->GetEntry(current_entry);
            return true;
        }
        int SetBranchAddress(TTree* tree);

};

class ProjectConeETCC : public anl::VANL_Module
{
    public:
        ProjectConeETCC();
        ~ProjectConeETCC();

        int mod_bgnrun() override;
        int mod_ana() override;
        int mod_endrun() override;

    protected:

        TFile * input_file;
        TTree * input_tree;
        TFile * output_file;
        TTree * output_tree;
        TH3F * image;
        TH1D * h1_cone_filling_ratio;
        ComptreeEvent event;

        /** parameters */
        double cone_thick_rad;
        double tangent_cone_thick;
        double distance_index_omega;
        double e_threshold_si;
        double e_threshold_cdte;
        double e_window_begin;
        double e_window_end;
        double theta_max_degree;
        double detector_z_position;
        bool is_event_list_only;
        double rotation_around_vertical_rad;
        bool enable_reject_fluor;
        bool enable_normalize_cone;

        /* branch */
        /* inherited from eventtree */
        unsigned int ti;
        unsigned int livetime;
        unsigned int unixtime;
        unsigned int ext1pps;
        unsigned int msec_counter;

        /* new branches */
        int num_hits;
        unsigned int externalCLK;
        unsigned int first_internalCLK;
        short hit1_detector;
        float hit1_energy;
        float hit1_posx;
        float hit1_posy;
        float hit1_posz;
        short hit2_detector;
        float hit2_energy;
        float hit2_posx;
        float hit2_posy;
        float hit2_posz;
        short hit3_detector;
        float hit3_energy;
        float hit3_posx;
        float hit3_posy;
        float hit3_posz;
        float totalenergy;

        /* for CMOS energy correction */
        TH1D * param2_cdtez;
        TF1 * si_ee_lo;
        TF1 * si_ee_up;

    private :
        int DefineBranch(TTree* tree);

        struct Hit
        {
            private :

                double x, y, z;
                double energy;

            public :
                Hit(double x, double y, double z, double energy)
                    : x(x), y(y), z(z), energy(energy)
                {}
                Hit(const Hit& other)
                    : x(other.x), y(other.y), z(other.z), energy(other.energy)
                {}
                Hit& operator=(const Hit& other)
                {
                    x = other.x;
                    y = other.y;
                    z = other.z;
                    energy = other.energy;
                    return *this;
                }
                TVector3 Postion() const
                {
                    return TVector3(x,y,z);
                }
                double Energy() const
                {
                    return energy;
                }
        };
        inline double ComptonTheta(double scat, double abso)
        {
            static const double mass_of_electron = 511.0;
            auto costheta = 1 - mass_of_electron * ( 1/abso - 1/(scat+abso) );
            if ( costheta<-1.0 || 1.0<costheta ) return -1;
            return std::fabs( TMath::ACos(costheta) );
        }
        inline bool IsInEnergyWindow(const double total_energy)
        {
            if ( e_window_begin<=total_energy && total_energy<=e_window_end )
                return true;
            return false;
        }
        inline bool IsInThetaRange(const Hit& scat, const Hit& abso)
        {
            auto theta = ComptonTheta( scat.Energy(), abso.Energy() );
            if ( 0<theta && theta<=theta_max_degree )
                return true;
            return false;
        }
        static inline bool IsFluor(double energy)
        {
            return 21.0<energy && energy<=28.0;
        }
};



#endif
