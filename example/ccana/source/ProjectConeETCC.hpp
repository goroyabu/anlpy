/***
    @file   ProjectConeETCC.hpp
    @date
    @author User
    @detail Automatically generated by mkanlproject
***/

#ifndef ProjectConeETCC_hpp
#define ProjectConeETCC_hpp

#include <tuple>

#include <TFile.h>
#include <TTree.h>
#include <TH2D.h>
#include <TH3F.h>
#include <TMath.h>
#include <TVector3.h>
#include <TF1.h>

#include <VANL_Module.hpp>

class ComptreeEvent
{
    private:
        TTree* tree;
        long nentries;
        long current_entry;

    public:

        int merged_si_nhit;
        std::vector<double> merged_epi_si;

        int n_reconst;
        std::vector<double> epi1;
        std::vector<double> epi2;
        std::vector<double> reconst_epi;
        std::vector<double> cdte_detx;
        std::vector<double> cdte_dety;
        std::vector<double> cdte_detz;
        double epi_total;

        int n_pixel;
        std::vector<double> epi_pixel_value;
        std::vector<double> cmos_detx;
        std::vector<double> cmos_dety;
        double min_cmos_detx;
        double min_cmos_dety;
        double eigen_ratio;
        double sum_pixel_value_around_init;
        double sum_pixel_value_around_end;

        bool reconstructed;
        double init_pos_cmos_detx;
        double init_pos_cmos_dety;
        double init_pos_cmos_detz;
        double phi_cmos_det;

        ComptreeEvent()
            : tree(nullptr)
            {}

        inline bool ExistBranch(TTree* tree, TString key)
        {
            if ( !tree->FindBranch(key) ) {
                std::cout << "TBranch " << key;
                std::cout << " is not found." << std::endl;
                return false;
            }
            return true;
        }
        inline bool ExistBranch(TString key)
        {
            return ExistBranch( this->tree, key);
        }
        inline bool Next()
        {
            ++current_entry;
            if ( current_entry>=nentries ) return false;
            tree->GetEntry(current_entry);
            return true;
        }
        inline long long int GetEntries() const
        {
            return this->nentries;
        }
        int SetBranchAddress(TTree* tree);

};

class ProjectConeETCC : public anl::VANL_Module
{
    public:
        ProjectConeETCC();
        ~ProjectConeETCC();

        int mod_bgnrun() override;
        int mod_ana() override;
        int mod_endrun() override;

    protected:

        TFile * input_file;
        TTree * input_tree;
        TFile * output_file;
        TTree * output_tree;
        TH3F * image;
        TH3F * image_etcc;
        TH1D * h1_cone_filling_ratio;
        TH1D * h1_arm_distribution;
        TH1D * h1_spd_distribution;
        TH2D * h2_arm_vs_spd;
        TH2D * h2_arm_distribition;
        TH2D * h2_spd_distribition;
        TH2D * h2_ene_cmos_vs_cdte;
        TH1D * h1_ene_sum_cmos_cdte;

        ComptreeEvent event;

        /** parameters */
        double cone_thick_rad;
        double arc_length_rad;
        double arc_length_sigma;
        double tangent_cone_thick;
        double distance_index_omega;
        double e_threshold_si;
        double e_threshold_cdte;
        double e_window_begin;
        double e_window_end;
        double theta_max_degree;
        double detector_z_position;
        bool is_event_list_only;
        double rotation_around_vertical_rad;
        bool enable_reject_fluor;
        bool enable_normalize_cone;
        double eigen_ratio_threshold;
        double pixel_ratio_threshold;

        TVector3 source_position;

        /* branch */
        /* inherited from eventtree */
        unsigned int ti;
        unsigned int livetime;
        unsigned int unixtime;
        unsigned int ext1pps;
        unsigned int msec_counter;

        /* new branches */
        int num_hits;
        unsigned int externalCLK;
        unsigned int first_internalCLK;
        short hit1_detector;
        float hit1_energy;
        float hit1_posx;
        float hit1_posy;
        float hit1_posz;
        short hit2_detector;
        float hit2_energy;
        float hit2_posx;
        float hit2_posy;
        float hit2_posz;
        short hit3_detector;
        float hit3_energy;
        float hit3_posx;
        float hit3_posy;
        float hit3_posz;
        float totalenergy;

        float theta_kine;
        float theta_geom;
        float theta_elec;
        float phi_esti;
        float phi_geom;

        float angle_inci;
        float de_over_dx;
        float prod_inci_phi;
        float sum_epi_around_init;
        float sum_epi_forward_init;

        /* for CMOS energy correction */
        TH1D * param2_cdtez;
        TF1 * si_ee_lo;
        TF1 * si_ee_up;

        TH2D * etrack_calc_dedx;

    private :

        struct Hit
        {
            private :

                double x, y, z;
                double energy;
                double phi;

            public :
                Hit(double x, double y, double z, double energy, double phi)
                    : x(x), y(y), z(z), energy(energy), phi(phi)
                {}
                Hit(const Hit& other)
                    : x(other.x), y(other.y), z(other.z),
                    energy(other.energy), phi(other.phi)
                {}
                Hit& operator=(const Hit& other)
                {
                    x = other.x;
                    y = other.y;
                    z = other.z;
                    energy = other.energy;
                    phi = other.phi;
                    return *this;
                }
                TVector3 Postion() const
                {
                    return TVector3(x,y,z);
                }
                double Energy() const
                {
                    return energy;
                }
                double Phi() const
                {
                    return phi;
                }
        };

    private:

        int DefineBranch(TTree* tree);
        void CalcComptonEvent(const Hit& si, const Hit& cdte);
        bool Projection(const Hit& si, const Hit& cdte);
        TH1D* GetFillingRatio
        (TH3F* image, const TVector3& scat, const TVector3& abso, double angle_theta_rad);
        double ScaleByFillingRatio(TH3F* th3, TH1D* ratio);

        inline static double ComptonTheta(double scat, double abso)
        {
            static const double mass_of_electron = 511.0;
            auto costheta = 1 - mass_of_electron * ( 1/abso - 1/(scat+abso) );
            if ( costheta<-1.0 || 1.0<costheta ) return -1;
            return std::fabs( TMath::ACos(costheta) );
        }
        inline bool IsInEnergyWindow(const double total_energy) const
        {
            if ( this->e_window_begin<=total_energy && total_energy<=this->e_window_end )
                return true;
            return false;
        }
        inline bool IsInThetaRange(const Hit& scat, const Hit& abso) const
        {
            auto theta = ComptonTheta( scat.Energy(), abso.Energy() );
            if ( 0<theta && theta<=this->theta_max_degree )
                return true;
            return false;
        }
        inline static bool IsFluor(double energy)
        {
            return 21.0<energy && energy<=28.0;
        }
        inline static TVector3 VoxelCenter(TH3* h, int bin)
        {
            int xbin, ybin, zbin;
            h->GetBinXYZ( bin, xbin, ybin, zbin );
            auto x = h->GetXaxis()->GetBinCenter(xbin);
            auto y = h->GetYaxis()->GetBinCenter(ybin);
            auto z = h->GetZaxis()->GetBinCenter(zbin);
            return TVector3(x, y, z);
        }
        inline static double GetBinContent(TH1D* h, double x)
        {
            auto bin = h->GetXaxis()->FindBin(x);
            if ( 1 <= bin && bin <= h->GetXaxis()->GetNbins() )
            return h->GetBinContent(bin);
            return 0.0;
        }
        inline static bool IsVectorInside( TH3F* image, const TVector3& vec)
        {
            auto x = image->GetXaxis()->GetXmin() <= vec.X() &&
                vec.X() <= image->GetXaxis()->GetXmax();
            if ( x == false ) return false;

            auto y = image->GetYaxis()->GetXmin() <= vec.Y() &&
                vec.Y() <= image->GetYaxis()->GetXmax();
            if ( y == false ) return false;

            auto z = image->GetZaxis()->GetXmin() <= vec.Z() &&
                vec.Z() <= image->GetZaxis()->GetXmax();

            return z;
        }
};



#endif
