/**
   @file   HistogramCompton.hpp
   @date   2020/09/09
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#ifndef HistogramCompton_hpp
#define HistogramCompton_hpp

#include <map>
#include <sstream>

#include <TFile.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TVector3.h>

#include <VANL_Module.hpp>

class HistogramCompton : public anl::VANL_Module
{
    
public:
    
    HistogramCompton();
    ~HistogramCompton();

    int mod_bgnrun() override;
    int mod_ana() override;
    int mod_endrun() override;

    static inline std::vector<std::string> split
    (const std::string& in, const std::string& delim=",")
    {
        std::vector<std::string> out;
        std::stringstream ss(in); std::string word;
        while( std::getline(ss, word, delim.c_str()[0]) )
            out.emplace_back(word);
        return out;
    }
    static inline std::vector<double> split_to_double
    (const std::string& in, const std::string& delim=",")
    {
        auto vstr = split(in, delim);
        std::vector<double> out;
        for ( auto str : vstr )
            out.emplace_back( std::stof(str) );
        return out;
    }
    static inline double compton_angle
    (const double scat, const double abso)
    {
        auto cos = 1 - 511.0 * ( 1/abso - 1/(scat+abso) );
        if ( cos <= -1.0 or 1.0 <= cos )
            return -1;
        auto deg = TMath::RadToDeg()*TMath::ACos(cos);
        return std::fabs( deg );
    }
    static inline double angle_of_3points
    (const TVector3& orig, const TVector3& scat, const TVector3& abso)
    {
        auto org_to_scat = scat - orig;
        auto scat_to_abso = abso - scat;
        auto rad = org_to_scat.Angle(scat_to_abso);
        auto deg = TMath::RadToDeg()*rad;
        return std::fabs( deg );
    }
    
private:

    enum CdTeEnergyMode { ANODE, AVERAGE };    
    enum AbsorptionEnergyMode { CDTE, PEAK_EXT_SI };    

    struct parameter_list
    {	
	std::vector<double> incident_energy_list;    
	double energy_window_half;
	double theta_window_max;

	TVector3 source_origin;

	CdTeEnergyMode cdte_energy_mode;
	AbsorptionEnergyMode abso_energy_mode;
	
    } parameter;
    
    TFile * output_file;

    class histos_each_layer
    {
	
    public:
	histos_each_layer(int detector_id, TString sub="");
	~histos_each_layer(){}
	
	int detid;
	TString subname;
	TH1D * th1_energy_spectra;
	TH2D * th2_energy_spectra_each_channels;

	TH2D * th2_energy_correlation;
	TH2D * th2_diff_vs_cathode;
	TH2D * th2_diff_vs_anode;

	void Write();

    };
    std::map<int,histos_each_layer*> histos;
    std::map<int,histos_each_layer*> histos_ecut;
    
    class histo2d_energy_vs_energy
    {

    public:
	histo2d_energy_vs_energy();

	std::map<std::string,TH2D*> histo;	

	void Write();
	
    } * th2_energy_vs_energy;


    class histo2d_hitpattern
    {
	
    public:

	histo2d_hitpattern(TString subname="");
	void Write();
	void Fill2Hits(int det1, int det2);
	void Fill3Hits(int det1, int det2, int det3);

    private:
	
	TH2D * histo_2hits;
	TH2D * histo_3hits;

	static inline int hit_pattern_id(int detid0, int detid1)
	{
	    auto first = detid0;
	    auto second = detid1;
	    if ( detid0>detid1 ) {
		first = detid1;
		second = detid0;
	    }
	    if      ( detid0==0 ) 
		return detid1;	    
	    else if ( detid0==1 ) 
		return detid1+4;
	    else if ( detid0==2 ) 
		return detid1+7;
	    else if ( detid0==3 ) 
		return detid1+9;
	    else if ( detid0==4 ) 
		return detid1+10;
	    return -1;
	}
	
    };
    histo2d_hitpattern * th2_hit_pattern;
    histo2d_hitpattern * th2_hit_pattern_ecut;
    
    class histos_energy_peak
    {
	
    public:
	histos_energy_peak(double peak, double width);
	inline bool IsMatchEnergy(double energy)
	{
	    // bool ok = std::fabs(energy-incident_energy)<=window_half_width;
	    // std::cout << energy << " " << incident_energy << " " << ok << std::endl;
	    return std::fabs(energy-incident_energy)<=window_half_width;
	}
	void Write();
	TH1D * th1_arm;
	TH2D * th2_scat_vs_arm;
	TH2D * th2_geom_vs_kine;
	double GetEnergy() const { return incident_energy; }
	
    private:
	double incident_energy;
	double window_half_width;
	
    };
    std::vector<histos_energy_peak*> histos_peaks;
    
    
    TH1D * th1_total_energy_spectra_comtpon;

    
};

#endif

