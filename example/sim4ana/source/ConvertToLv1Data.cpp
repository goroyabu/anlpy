/**
   @file   ConvertToLv1Data.cpp
   @date   2020/09/03
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "ConvertToLv1Data.hpp"

#include <vector>

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

#include <ANLmanager.hpp>
// #include "/Users/goroyabu/github/anlpy/example/dsdana/source/DSDdatabase.hpp"

ConvertToLv1Data::ConvertToLv1Data()
    : anl::VANL_Module("ConvertToLv1Data", "0.1")
{
}
ConvertToLv1Data::~ConvertToLv1Data()
{
}

int ConvertToLv1Data::mod_bgnrun()
{
    // auto manager = anl::ANLmanager::Instance();  
    // auto database = (DSDdatabase*)manager.get_module("DSDdatabase");
    // if ( !database || database->mod_name()!="DSDdatabase") {
    //     cout << "***Error*** DSDdatabase does not exist." << endl;
    //     return anl::ANL_NG;
    // }
    // int nxside = database->GetNxside();
    // int nyside = database->GetNyside();
    auto nxside = bnk::get<int>( "DSDinfo_nstrips_x" );
    auto nyside = bnk::get<int>( "DSDinfo_nstrips_y" );
    
    bnk::define<int>("nsignal_x_lv1", 1);
    bnk::define<int>("nsignal_y_lv1", 1);
    bnk::define<int>("detid_x_lv1", nxside);
    bnk::define<int>("detid_y_lv1", nyside);
    bnk::define<int>("material_x_lv1", nyside);
    bnk::define<int>("material_y_lv1", nyside);
    bnk::define<int>("stripid_x_lv1", nxside);
    bnk::define<int>("stripid_y_lv1", nyside);
    bnk::define<int>("adc_cmn_x_lv2", nxside);
    bnk::define<int>("adc_cmn_y_lv2", nyside);
    bnk::define<float>("epi_x_lv1", nxside);
    bnk::define<float>("epi_y_lv1", nyside);

    bnk::setkeytosize<int>("detid_x_lv1", "nsignal_x_lv1");
    bnk::setkeytosize<int>("stripid_x_lv1", "nsignal_x_lv1");
    bnk::setkeytosize<int>("adc_cmn_x_lv2", "nsignal_x_lv1");
    bnk::setkeytosize<float>("epi_x_lv1", "nsignal_x_lv1");

    bnk::setkeytosize<int>("detid_y_lv1", "nsignal_y_lv1");
    bnk::setkeytosize<int>("stripid_y_lv1", "nsignal_y_lv1");
    bnk::setkeytosize<int>("adc_cmn_y_lv2", "nsignal_y_lv1");
    bnk::setkeytosize<float>("epi_y_lv1", "nsignal_y_lv1");

    evs::define("nsignal_x_lv1==0 && nsignal_y_lv1==0");
    evs::define("nsignal_x_lv1==1 && nsignal_y_lv1==0");
    evs::define("nsignal_x_lv1==0 && nsignal_y_lv1==1");
    evs::define("nsignal_x_lv1==1 && nsignal_y_lv1==1");
    evs::define("nsignal_x_lv1==2 && nsignal_y_lv1==0");
    evs::define("nsignal_x_lv1==0 && nsignal_y_lv1==2");
    evs::define("nsignal_x_lv1==2 && nsignal_y_lv1==1");
    evs::define("nsignal_x_lv1==1 && nsignal_y_lv1==2");
    evs::define("nsignal_x_lv1==2 && nsignal_y_lv1==2");
    evs::define("nsignal_x_lv1>=3 || nsignal_y_lv1>=3");
    
    return anl::ANL_OK;
}

int ConvertToLv1Data::mod_ana()
{
    auto nhits_x_in = bnk::get<int>( "nhits_x_res" );
    auto detid_x_in = bnk::getv<int>( "detid_x_res" );
    auto material_x_in = bnk::getv<int>( "material_x_res" );
    // auto flag_x_in = bnk::getv<int>( "flag_x_res" );
    auto strip_x_in = bnk::getv<int>( "strip_x_res" );
    auto edep_x_in = bnk::getv<double>( "edep_x_res" );
    auto pos_x_in = bnk::getv<double>( "pos_x_res" );

    auto nhits_y_in = bnk::get<int>( "nhits_y_res" );
    auto detid_y_in = bnk::getv<int>( "detid_y_res" );
    auto material_y_in = bnk::getv<int>( "material_y_res" );
    // auto flag_y_in = bnk::getv<int>( "flag_y_res" );
    auto strip_y_in = bnk::getv<int>( "strip_y_res" );
    auto edep_y_in = bnk::getv<double>( "edep_y_res" );
    auto pos_y_in = bnk::getv<double>( "pos_y_res" );
    
    bnk::put<int>( "nsignal_x_lv1", nhits_x_in );
    bnk::put<int>( "nsignal_y_lv1", nhits_y_in );
    bnk::put<int>( "detid_x_lv1", detid_x_in, 0, nhits_x_in );
    bnk::put<int>( "detid_y_lv1", detid_y_in, 0, nhits_y_in );
    bnk::put<int>( "material_x_lv1", material_x_in, 0, nhits_x_in );
    bnk::put<int>( "material_y_lv1", material_y_in, 0, nhits_y_in ); 
    bnk::put<int>( "stripid_x_lv1", strip_x_in, 0, nhits_x_in );
    bnk::put<int>( "stripid_y_lv1", strip_y_in, 0, nhits_y_in );

    std::vector<float> epi_x_lv1, epi_y_lv1;
    for ( auto e : edep_x_in ) epi_x_lv1.emplace_back(e);
    for ( auto e : edep_y_in ) epi_y_lv1.emplace_back(e);    
    bnk::put<float>( "epi_x_lv1", epi_x_lv1, 0, nhits_x_in );
    bnk::put<float>( "epi_y_lv1", epi_y_lv1, 0, nhits_y_in );

    std::vector<int> adc_cmn_x_lv2, adc_cmn_y_lv2;
    for ( auto e : edep_x_in ) adc_cmn_x_lv2.emplace_back( (int)e );
    for ( auto e : edep_y_in ) adc_cmn_y_lv2.emplace_back( (int)e );
    bnk::put<int>( "adc_cmn_x_lv2", adc_cmn_x_lv2, 0, nhits_x_in );
    bnk::put<int>( "adc_cmn_y_lv2", adc_cmn_y_lv2, 0, nhits_y_in );

    if ( nhits_x_in==0 && nhits_y_in==0 ) {
	evs::set("nsignal_x_lv1==0 && nsignal_y_lv1==0");
	return anl::ANL_SKIP;
    }
    else if ( nhits_x_in==1 && nhits_y_in==0 )
	evs::set("nsignal_x_lv1==1 && nsignal_y_lv1==0");
    else if ( nhits_x_in==0 && nhits_y_in==1 )
	evs::set("nsignal_x_lv1==0 && nsignal_y_lv1==1");
    else if ( nhits_x_in==1 && nhits_y_in==1 )
	evs::set("nsignal_x_lv1==1 && nsignal_y_lv1==1");
    else if ( nhits_x_in==2 && nhits_y_in==0 )
	evs::set("nsignal_x_lv1==2 && nsignal_y_lv1==0");
    else if ( nhits_x_in==0 && nhits_y_in==2 )
	evs::set("nsignal_x_lv1==0 && nsignal_y_lv1==2");
    else if ( nhits_x_in==2 && nhits_y_in==1 )
	evs::set("nsignal_x_lv1==2 && nsignal_y_lv1==1");
    else if ( nhits_x_in==1 && nhits_y_in==2 )
	evs::set("nsignal_x_lv1==1 && nsignal_y_lv1==2");
    else if ( nhits_x_in==2 && nhits_y_in==2 )
	evs::set("nsignal_x_lv1==2 && nsignal_y_lv1==2");
    else 
	evs::set("nsignal_x_lv1>=3 || nsignal_y_lv1>=3");
    
    return anl::ANL_OK;
}

int ConvertToLv1Data::mod_endrun()
{    
    return anl::ANL_OK;
}

