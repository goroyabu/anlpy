/**
   @file   BeginG4TreeAnalysis.cpp
   @date   2020/08/24
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "BeginG4TreeAnalysis.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

namespace bnk
{
    template<typename T> int define
    (const std::string& key, const int size, const std::string& sizeref)
    {
	auto result = define<T>( key, size );
	if ( result!=0 ) return result;
	return setkeytosize<T>( key, sizeref );
    }
}

BeginG4TreeAnalysis::BeginG4TreeAnalysis()
    : anl::VANL_Module("BeginG4TreeAnalysis", "0.1")
{
    /** Parameters can be modified via a method 'SetParameter' in Python **/
    // define_parameter<std::string>("input_file", "input.txt");
}
BeginG4TreeAnalysis::~BeginG4TreeAnalysis()
{
}

int BeginG4TreeAnalysis::mod_bgnrun()
{
    /** This function is called at the begging of the run **/
    cout << mod_name2() << "::mod_bgnrun()";
    cout << " -> Hello! :D" << endl;

    /** Example of operations described here **/

    /** Opening files **/
    // std::string input_file = get_parameter<std::string>( "input.txt" );
    // ifs = std::ifstream( input_file );

    /** Definition of data buffers (BNK) **/
    // bnk::define<std::string>( "time_stamp" );
    // bnk::define<double>( "energy_deposit" );

    /** Definition of event flags (EVS) **/
    // evs::define( "multiple_signals_event" );

    constexpr static int npixels = 1000;

    bnk::define<int>( "nhits_raw" );
    bnk::define<int>( "detid_raw", npixels, "nhits_raw" );
    bnk::define<int>( "material_raw", npixels, "nhits_raw" );
    bnk::define<int>( "strip_x_raw", npixels, "nhits_raw" );
    bnk::define<int>( "strip_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "edep_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pos_x_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pos_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pos_z_raw", npixels, "nhits_raw" );
    bnk::define<double>( "dir_x_raw", npixels, "nhits_raw" );
    bnk::define<double>( "dir_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "dir_z_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pixel_center_x_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pixel_center_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pixel_center_z_raw", npixels, "nhits_raw" );

    // evs::define( "exist_raw_signals" ); 
    
    // bnk::define<int>( "nhits_dif" );
    // bnk::define<int>( "flag_dif", npixels, "nhits_dif" ); // Whether exist in raw data
    // bnk::define<int>( "strip_x_dif", npixels, "nhits_dif" );
    // bnk::define<int>( "strip_y_dif", npixels, "nhits_dif" );
    // bnk::define<double>( "edep_dif", npixels, "nhits_dif" );
    
    // // bnk::define<int>( "nhits_res" );
    // // bnk::define<int>( "strip_x_res", npixels, "nhits_res" );
    // // bnk::define<int>( "strip_y_res", npixels, "nhits_res" );
    // // bnk::define<double>( "edep_res", npixels, "nhits_res" );

    // bnk::define<int>( "nhits_x_str" );
    // bnk::define<int>( "strip_x_str", npixels, "nhits_x_str" );
    // bnk::define<double>( "edep_x_str", npixels, "nhits_x_str");
    // bnk::define<int>( "nhits_y_str" );
    // bnk::define<int>( "strip_y_str", npixels, "nhits_y_str" );
    // bnk::define<double>( "edep_y_str", npixels, "nhits_y_str");
    
    // evs::define( "1LayerTriggered" );
    // evs::define( "SCCoinTriggered" );

    // bnk::define<int>( "nhits_x_spa" );
    // bnk::define<int>( "strip_x_spa", npixels, "nhits_x_spa" );
    // bnk::define<double>( "edep_x_spa", npixels, "nhits_x_spa" );
    
    return anl::ANL_OK;
}

int BeginG4TreeAnalysis::mod_ana()
{
    auto nhits = bnk::get<int>( "nhits" );
    bnk::put<int>( "nhits_raw", nhits );

    if ( nhits>0 ) evs::set( "exist_raw_signals" );     

    auto detid = bnk::getv<int>( "detid" );
    bnk::put<int>( "detid_raw", detid, 0, nhits );    

    auto mate = bnk::getv<int>( "material" );
    bnk::put<int>( "material_raw", mate, 0, nhits );
    
    bnk::put<int>( "strip_x_raw", bnk::getv<int>( "strip_x" ), 0, nhits );
    bnk::put<int>( "strip_y_raw", bnk::getv<int>( "strip_y" ), 0, nhits );
    bnk::put<double>( "edep_raw", bnk::getv<double>( "edep" ), 0, nhits );
    bnk::put<double>( "pos_x_raw", bnk::getv<double>( "pos_x" ), 0, nhits );
    bnk::put<double>( "pos_y_raw", bnk::getv<double>( "pos_y" ), 0, nhits );
    bnk::put<double>( "pos_z_raw", bnk::getv<double>( "pos_z" ), 0, nhits );
    bnk::put<double>( "dir_x_raw", bnk::getv<double>( "dir_x" ), 0, nhits );
    bnk::put<double>( "dir_y_raw", bnk::getv<double>( "dir_y" ), 0, nhits );
    bnk::put<double>( "dir_z_raw", bnk::getv<double>( "dir_z" ), 0, nhits );
    bnk::put<double>( "pixel_center_x_raw", bnk::getv<double>( "pixel_center_x" ), 0, nhits );
    bnk::put<double>( "pixel_center_y_raw", bnk::getv<double>( "pixel_center_y" ), 0, nhits );
    bnk::put<double>( "pixel_center_z_raw", bnk::getv<double>( "pixel_center_z" ), 0, nhits );
    
    /** This function is called at every events **/
    // cout << mod_name2() << "::mod_ana()" << endl;

    /** 1. Get values from data buffers (BNK) **/
    /**    Previous ANL modules often define buffers used here **/
    // int n_signals = bnk::define<int>( "n_signals" );
    // double energy_deposit = bnk::define<double>( "adc_value" ) * 0.25;

    /** 2. Use flags set by previous modules (EVS) **/
    // if ( evs::get("bad_signal_event") ) return ANL_SKIP;

    /** 3. Put values to data buffers (BNK) **/
    /**    This module often defines buffers used here **/
    // bnk::put<std::string>("time_stamp", "2020-04-03 21:12:15");
    // bnk::put<double>("energy_deposit", energy_deposit);

    /** 4. Set event flags in order for follwing modules to skip the same analysis **/
    // if ( n_signals > 1 || energy_deposit >= 5.0 ) evs::set( "multiple_signals_event" );

       
    return anl::ANL_OK;
}

int BeginG4TreeAnalysis::mod_endrun()
{
    /** This function is called at the end of the run **/
    cout << mod_name2() << "::mod_endrun()";
    cout << " -> Good Bye. :)" << endl;

    /** Example of operations described here **/

    /** Closing files **/
    // ifs.close(); // std::ifstream

    return anl::ANL_OK;
}

