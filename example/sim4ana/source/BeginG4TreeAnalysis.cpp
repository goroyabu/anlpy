/**
   @file   BeginG4TreeAnalysis.cpp
   @date   2020/08/24
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "BeginG4TreeAnalysis.hpp"

#include <iostream>
using std::cout;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

namespace bnk
{
    template<typename T> int define
    (const std::string& key, const int size, const std::string& sizeref)
    {
	auto result = define<T>( key, size );
	if ( result!=0 ) return result;
	return setkeytosize<T>( key, sizeref );
    }
}

BeginG4TreeAnalysis::BeginG4TreeAnalysis()
    : anl::VANL_Module("BeginG4TreeAnalysis", "0.1")
{
    /** Parameters can be modified via a method 'SetParameter' in Python **/
    // define_parameter<std::string>("input_file", "input.txt");
    define_parameter<int>( "convert_to_lv3_data", 0 );
}
BeginG4TreeAnalysis::~BeginG4TreeAnalysis()
{
}

int BeginG4TreeAnalysis::mod_bgnrun()
{
    /** This function is called at the begging of the run **/
    // cout << mod_name2() << "::mod_bgnrun()";
    // cout << " -> Hello! :D" << endl;

    parameter.is_enabled_convert_to_lv3_data
	= get_parameter<int>( "convert_to_lv3_data" );
    
    /** Example of operations described here **/

    /** Opening files **/
    // std::string input_file = get_parameter<std::string>( "input.txt" );
    // ifs = std::ifstream( input_file );

    /** Definition of data buffers (BNK) **/
    // bnk::define<std::string>( "time_stamp" );
    // bnk::define<double>( "energy_deposit" );

    /** Definition of event flags (EVS) **/
    // evs::define( "multiple_signals_event" );

    constexpr static int npixels = 1000;

    bnk::define<int>( "nhits_raw" );
    bnk::define<int>( "detid_raw", npixels, "nhits_raw" );
    bnk::define<int>( "material_raw", npixels, "nhits_raw" );
    bnk::define<int>( "strip_x_raw", npixels, "nhits_raw" );
    bnk::define<int>( "strip_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "edep_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pos_x_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pos_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pos_z_raw", npixels, "nhits_raw" );
    bnk::define<double>( "dir_x_raw", npixels, "nhits_raw" );
    bnk::define<double>( "dir_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "dir_z_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pixel_center_x_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pixel_center_y_raw", npixels, "nhits_raw" );
    bnk::define<double>( "pixel_center_z_raw", npixels, "nhits_raw" );
    
    if ( parameter.is_enabled_convert_to_lv3_data==false ) return anl::ANL_OK;

    std::cout << "> Lv.3 branches are defined by BeginG4TreeAnalysis" << std::endl; 
    
    bnk::define<int>  ("nhit_lv3",             1);
    bnk::define<int>  ("detid_lv3",          128);
    bnk::define<float>("epi_lv3",            128);
    bnk::define<float>("epi_x_lv3",          128);
    bnk::define<float>("epi_y_lv3",          128);
    bnk::define<float>("pos_x_lv3",          128);
    bnk::define<float>("pos_y_lv3",          128);
    bnk::define<float>("pos_z_lv3",          128);
    bnk::define<float>("width_x_lv3",        128);
    bnk::define<float>("width_y_lv3",        128);
    bnk::define<float>("width_z_lv3",        128);
    // bnk::define<int>  ("n_lv2signal_x_lv3",    1);
    // bnk::define<int>  ("n_lv2signal_y_lv3",    1);
    // bnk::define<int>  ("lv2signal_id_x_lv3", 128);
    // bnk::define<int>  ("lv2signal_id_y_lv3", 128);

    bnk::setkeytosize<int>("detid_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("epi_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("epi_x_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("epi_y_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("pos_x_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("pos_y_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("pos_z_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("width_x_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("width_y_lv3", "nhit_lv3");
    bnk::setkeytosize<float>("width_z_lv3", "nhit_lv3");
    // bnk::setkeytosize<int>("lv2signal_id_x_lv3", "n_lv2signal_x_lv3");
    // bnk::setkeytosize<int>("lv2signal_id_y_lv3", "n_lv2signal_y_lv3");
    
    // evs::define( "exist_raw_signals" ); 
    
    // bnk::define<int>( "nhits_dif" );
    // bnk::define<int>( "flag_dif", npixels, "nhits_dif" ); // Whether exist in raw data
    // bnk::define<int>( "strip_x_dif", npixels, "nhits_dif" );
    // bnk::define<int>( "strip_y_dif", npixels, "nhits_dif" );
    // bnk::define<double>( "edep_dif", npixels, "nhits_dif" );
    
    // // bnk::define<int>( "nhits_res" );
    // // bnk::define<int>( "strip_x_res", npixels, "nhits_res" );
    // // bnk::define<int>( "strip_y_res", npixels, "nhits_res" );
    // // bnk::define<double>( "edep_res", npixels, "nhits_res" );

    // bnk::define<int>( "nhits_x_str" );
    // bnk::define<int>( "strip_x_str", npixels, "nhits_x_str" );
    // bnk::define<double>( "edep_x_str", npixels, "nhits_x_str");
    // bnk::define<int>( "nhits_y_str" );
    // bnk::define<int>( "strip_y_str", npixels, "nhits_y_str" );
    // bnk::define<double>( "edep_y_str", npixels, "nhits_y_str");
    
    // evs::define( "1LayerTriggered" );
    // evs::define( "SCCoinTriggered" );

    // bnk::define<int>( "nhits_x_spa" );
    // bnk::define<int>( "strip_x_spa", npixels, "nhits_x_spa" );
    // bnk::define<double>( "edep_x_spa", npixels, "nhits_x_spa" );
    
    return anl::ANL_OK;
}

int BeginG4TreeAnalysis::mod_ana()
{
    auto nhits = bnk::get<int>( "nhits" );
    bnk::put<int>( "nhits_raw", nhits );

    if ( nhits>0 ) evs::set( "exist_raw_signals" );     

    auto detid = bnk::getv<int>( "detid" );
    bnk::put<int>( "detid_raw", detid, 0, nhits );    

    auto mate = bnk::getv<int>( "material" );
    bnk::put<int>( "material_raw", mate, 0, nhits );
    
    bnk::put<int>( "strip_x_raw", bnk::getv<int>( "strip_x" ), 0, nhits );
    bnk::put<int>( "strip_y_raw", bnk::getv<int>( "strip_y" ), 0, nhits );
    bnk::put<double>( "edep_raw", bnk::getv<double>( "edep" ), 0, nhits );
    bnk::put<double>( "pos_x_raw", bnk::getv<double>( "pos_x" ), 0, nhits );
    bnk::put<double>( "pos_y_raw", bnk::getv<double>( "pos_y" ), 0, nhits );
    bnk::put<double>( "pos_z_raw", bnk::getv<double>( "pos_z" ), 0, nhits );
    bnk::put<double>( "dir_x_raw", bnk::getv<double>( "dir_x" ), 0, nhits );
    bnk::put<double>( "dir_y_raw", bnk::getv<double>( "dir_y" ), 0, nhits );
    bnk::put<double>( "dir_z_raw", bnk::getv<double>( "dir_z" ), 0, nhits );
    bnk::put<double>( "pixel_center_x_raw", bnk::getv<double>( "pixel_center_x" ), 0, nhits );
    bnk::put<double>( "pixel_center_y_raw", bnk::getv<double>( "pixel_center_y" ), 0, nhits );
    bnk::put<double>( "pixel_center_z_raw", bnk::getv<double>( "pixel_center_z" ), 0, nhits );

    if ( parameter.is_enabled_convert_to_lv3_data==false ) return anl::ANL_OK;
    
    auto edep = bnk::getv<double>( "edep" );
    auto pos_x = bnk::getv<double>( "pos_x" );
    auto pos_y = bnk::getv<double>( "pos_y" );
    auto pos_z = bnk::getv<double>( "pos_z" );
    auto dir_x = bnk::getv<double>( "dir_x" );
    auto dir_y = bnk::getv<double>( "dir_y" );
    auto dir_z = bnk::getv<double>( "dir_z" );
    auto pixel_center_x = bnk::getv<double>( "pixel_center_x" );
    auto pixel_center_y = bnk::getv<double>( "pixel_center_y" );
    auto pixel_center_z = bnk::getv<double>( "pixel_center_z" );
    
    // std::vector<double> width_x, width_y, width_z;
    std::vector<float> edep_f;
    std::vector<float> pos_x_f, pos_y_f, pos_z_f;
    std::vector<float> dir_x_f, dir_y_f, dir_z_f;
    std::vector<float> width_x_f, width_y_f, width_z_f;
    
    for ( int index=0; index<nhits; ++index ) {
	edep_f.emplace_back( edep[index] );
	pos_x_f.emplace_back( pos_x[index] );
	pos_y_f.emplace_back( pos_y[index] );
	pos_z_f.emplace_back( pos_z[index] );
	dir_x_f.emplace_back( dir_x[index] );
	dir_y_f.emplace_back( dir_y[index] );
	dir_z_f.emplace_back( dir_z[index] );
	width_x_f.emplace_back( 0.250 );	
	width_y_f.emplace_back( 0.250 );
	width_z_f.emplace_back( 0.750 );	
    }    
    
    bnk::put<int>  ( "nhit_lv3",    nhits );
    bnk::put<int>  ( "detid_lv3",   detid,     0, nhits );
    bnk::put<float>( "epi_lv3",     edep_f,    0, nhits );
    bnk::put<float>( "epi_x_lv3",   edep_f,    0, nhits );
    bnk::put<float>( "epi_y_lv3",   edep_f,    0, nhits );
    bnk::put<float>( "pos_x_lv3",   pos_x_f,   0, nhits );
    bnk::put<float>( "pos_y_lv3",   pos_y_f,   0, nhits );
    bnk::put<float>( "pos_z_lv3",   pos_z_f,   0, nhits );
    bnk::put<float>( "width_x_lv3", width_x_f, 0, nhits );
    bnk::put<float>( "width_y_lv3", width_y_f, 0, nhits );
    bnk::put<float>( "width_z_lv3", width_z_f, 0, nhits );       
    // bnk::put<int>  ("n_lv2signal_x_lv3", m_n_lv2signal_x_lv3);
    // bnk::put<int>  ("n_lv2signal_y_lv3", m_n_lv2signal_y_lv3);
    // bnk::put<int>  ("lv2signal_id_x_lv3", m_lv2signal_id_x_lv3, 0, m_n_lv2signal_x_lv3);
    // bnk::put<int>  ("lv2signal_id_y_lv3", m_lv2signal_id_y_lv3, 0, m_n_lv2signal_y_lv3);

    
    /** This function is called at every events **/
    // cout << mod_name2() << "::mod_ana()" << endl;

    /** 1. Get values from data buffers (BNK) **/
    /**    Previous ANL modules often define buffers used here **/
    // int n_signals = bnk::define<int>( "n_signals" );
    // double energy_deposit = bnk::define<double>( "adc_value" ) * 0.25;

    /** 2. Use flags set by previous modules (EVS) **/
    // if ( evs::get("bad_signal_event") ) return ANL_SKIP;

    /** 3. Put values to data buffers (BNK) **/
    /**    This module often defines buffers used here **/
    // bnk::put<std::string>("time_stamp", "2020-04-03 21:12:15");
    // bnk::put<double>("energy_deposit", energy_deposit);

    /** 4. Set event flags in order for follwing modules to skip the same analysis **/
    // if ( n_signals > 1 || energy_deposit >= 5.0 ) evs::set( "multiple_signals_event" );

       
    return anl::ANL_OK;
}

int BeginG4TreeAnalysis::mod_endrun()
{
    /** This function is called at the end of the run **/
    cout << mod_name2() << "::mod_endrun()";
    cout << " -> Good Bye. :)" << endl;

    /** Example of operations described here **/

    /** Closing files **/
    // ifs.close(); // std::ifstream

    return anl::ANL_OK;
}

