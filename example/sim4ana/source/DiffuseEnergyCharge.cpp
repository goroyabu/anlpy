/**
   @file   DiffuseEnergyCharge.cpp
   @date   2020/08/24
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "DiffuseEnergyCharge.hpp"

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

namespace bnk
{
    template<typename T> int define
    (const std::string& key, const int size, const std::string& sizeref)
    {
        auto result = define<T>( key, size );
        if ( result!=0 ) return result;
        return setkeytosize<T>( key, sizeref );
    }
}

DiffuseEnergyCharge::DiffuseEnergyCharge()
    : anl::VANL_Module("DiffuseEnergyCharge", "0.1")
{
    define_parameter<int>("diffusion_mode", 1);
    define_parameter<std::string>("efield_mode", "linear");

    define_parameter<double>("temperature", -20);
    define_parameter<double>("thickness", 0.500);
    define_parameter<double>("spread_factor_anode", 1.0);    
    define_parameter<double>("bias_voltage", 250.0);

    // detector_pixel_dif
    // 	= new TH2D( "detector", "detector", 128, -16, 16, 128, -16, 16);
    detector_pixels.SetAxis(128, -16, 16, 128, -16, 16);

    bnk::define<int>( "DSDinfo_nstrips_x" );
    bnk::define<int>( "DSDinfo_nstrips_y" );
    bnk::define<double>( "DSDinfo_xmin" );
    bnk::define<double>( "DSDinfo_xmax" );
    bnk::define<double>( "DSDinfo_ymin" );
    bnk::define<double>( "DSDinfo_ymax" );

    bnk::put<int>( "DSDinfo_nstrips_x", 128 );
    bnk::put<int>( "DSDinfo_nstrips_y", 128 );
    bnk::put<double>( "DSDinfo_xmin", -16 );
    bnk::put<double>( "DSDinfo_xmax", 16 );
    bnk::put<double>( "DSDinfo_ymin", -16 );
    bnk::put<double>( "DSDinfo_ymax", 16 );    
}
DiffuseEnergyCharge::~DiffuseEnergyCharge()
{
}

int DiffuseEnergyCharge::mod_bgnrun()
{    
    constexpr static int npixels = 1000;
    bnk::define<int>( "nhits_dif" );
    bnk::define<int>( "detid_dif", npixels, "nhits_dif" );
    bnk::define<int>( "material_dif", npixels, "nhits_dif" );
    bnk::define<int>( "flag_dif", npixels, "nhits_dif" );
    bnk::define<int>( "strip_x_dif", npixels, "nhits_dif" );
    bnk::define<int>( "strip_y_dif", npixels, "nhits_dif" );
    bnk::define<double>( "edep_dif", npixels, "nhits_dif" );
    bnk::define<double>( "pos_x_dif", npixels, "nhits_dif" );
    bnk::define<double>( "pos_y_dif", npixels, "nhits_dif" );
    bnk::define<double>( "pos_z_dif", npixels, "nhits_dif" );

    parameter.diffusion_mode = get_parameter<int>("diffusion_mode");
    parameter.temperature = get_parameter<double>("temperature");
    parameter.thickness = get_parameter<double>("thickness");

    parameter.bias_voltage = get_parameter<double>("bias_voltage");
    parameter.efield_mean = parameter.bias_voltage/parameter.thickness;

    auto efmode = get_parameter<std::string>("efield_mode");
    if ( efmode=="linear" )
	parameter.efield_mode = parameter_list::linear;
    else if ( efmode=="constant" )
	parameter.efield_mode = parameter_list::constant;

    parameter.spread_factor_anode = get_parameter<double>("spread_factor_anode");
    
    return anl::ANL_OK;
}

int DiffuseEnergyCharge::mod_ana()
{
    auto nhits_raw = bnk::get<int>("nhits_raw");
    auto detid_raw = bnk::getv<int>("detid_raw");
    auto material_raw = bnk::getv<int>("material_raw");
    auto strip_x_raw = bnk::getv<int>("strip_x_raw");
    auto strip_y_raw = bnk::getv<int>("strip_y_raw");
    auto edep_raw = bnk::getv<double>("edep_raw");
    auto pos_x_raw = bnk::getv<double>("pos_x_raw");
    auto pos_y_raw = bnk::getv<double>("pos_y_raw");
    auto pos_z_raw = bnk::getv<double>("pos_z_raw");
    auto dir_x_raw = bnk::getv<double>("dir_x_raw");
    auto dir_y_raw = bnk::getv<double>("dir_y_raw");
    auto dir_z_raw = bnk::getv<double>("dir_z_raw");
    auto pixel_center_x_raw = bnk::getv<double>("pixel_center_x_raw");
    auto pixel_center_y_raw = bnk::getv<double>("pixel_center_y_raw");
    auto pixel_center_z_raw = bnk::getv<double>("pixel_center_z_raw");
    
    // for ( auto&& [ detid, h2 ] : detector_pixels.histo ) h2->Reset();
    // for ( auto&& [ detid, n ] : detector_pixels.nhits ) n = 0;

    // cout << "begin" << endl;

    // cout << "reset" << endl;
    detector_pixels.Reset();

    // cout << "for ihit" << endl;
    
    for ( int ihit=0; ihit<nhits_raw; ++ihit ) {
	
	hit h;
	// cout << "mate" << endl;
    	h.material = material_raw[ihit];
	// cout << "detid " << endl;
    	h.detid    = detid_raw[ihit];
    	// h.strip_x  = strip_x_raw[ihit];
    	// h.strip_y  = strip_y_raw[ihit];
	// cout << "edep" << endl;
    	h.edep     = edep_raw[ihit];
	// cout << "pos" << endl;
    	h.pos_x    = pos_x_raw[ihit];
    	h.pos_y    = pos_y_raw[ihit];
    	h.pos_z    = pos_z_raw[ihit];
	// cout << "pixz" << endl;
    	h.pixel_center_z = pixel_center_z_raw[ihit];

	//cout << "exist" << endl;
	if ( detector_pixels.Exist(h.detid)==false ) {
	    // cout << "add det" << endl;
    	    detector_pixels.AddDetector(h.detid, h.material, h.pos_z);
    	}

	// cout << "incre nhits" << endl;
	detector_pixels.detectors[h.detid]->nhits += 1;
	// cout << detector_pixels.nhits[h.detid] << endl;

	// cout << "fill diff" << endl;
	// this->FillDiffusedEnergy(detector_pixels.histo[h.detid], h);
	this->FillDiffusedEnergy(detector_pixels, h);
    }

    int nhits_dif = 0;
    std::vector<int> material_dif;
    std::vector<int> detid_dif;
    std::vector<int> strip_x_dif;
    std::vector<int> strip_y_dif;
    std::vector<double> edep_dif;
    std::vector<double> pos_x_dif;
    std::vector<double> pos_y_dif;
    std::vector<double> pos_z_dif;

    // cout << "for dets" << endl;
    for ( auto [ detid, detector ] : detector_pixels.detectors ) {

	// cout << "nhits" << endl;
	if ( detector->nhits==0 ) continue;
	
	// auto npixels = h2->GetNcells();
	// for ( int pixel=0; pixel<npixels; ++pixel ) {

	// cout << "for content" << endl;
	for ( auto [ pixel, edep ] : detector->content ) {
	
	    // continue;
	    // if ( h2->IsBinOverflow(pixel) || h2->IsBinUnderflow(pixel) )
	    // 	continue;
	    
	    // int xbin, ybin;
	    // // h2->GetBinXYZ(pixel, xbin, ybin, zbin);
	    // xbin = pixel%(detector_pixels.nbinsx+2);
	    // ybin = ( (pixel-xbin)/(detector_pixels.nbinsx+2) )
	    // 	%(detector_pixels.nbinsy+2);
	    auto [ xbin, ybin ] = detector->GetBinXYZ( pixel );
	    if ( detector->IsBinInRange(xbin, ybin)==false ) continue;
	    
	    // if ( xbin<=0 || detector_pixels.nbinsx+1<xbin ) continue;
	    // if ( ybin<=0 || detector_pixels.nbinsy+1<ybin ) continue;
	    
	    // auto edep = h2->GetBinContent( pixel );
	    // cout << "edep=" << edep << endl;
	    if ( edep==0.0 ) continue;
	    // continue;
	    
	    edep_dif.emplace_back( edep );
	    detid_dif.emplace_back( detid );
	    
	    auto material = detector->material;
	    material_dif.emplace_back( material );
	    
	    strip_x_dif.emplace_back( xbin );
	    strip_y_dif.emplace_back( ybin );
	    
	    auto pos_x = detector->histo->GetXaxis()->GetBinCenter(xbin);
	    auto pos_y = detector->histo->GetYaxis()->GetBinCenter(ybin);	    
	    pos_x_dif.emplace_back( pos_x );
	    pos_y_dif.emplace_back( pos_y );

	    auto pos_z = detector->pos_z;
	    pos_z_dif.emplace_back( pos_z );

	    ++nhits_dif;
	}
	
    }
    
    bnk::put<int>("nhits_dif", nhits_dif);
    bnk::put<int>("material_dif", material_dif, 0, nhits_dif);
    bnk::put<int>("detid_dif", detid_dif, 0, nhits_dif);
    bnk::put<int>("strip_x_dif", strip_x_dif, 0, nhits_dif);
    bnk::put<int>("strip_y_dif", strip_y_dif, 0, nhits_dif);
    bnk::put<double>("edep_dif", edep_dif, 0, nhits_dif);
    bnk::put<double>("pos_x_dif", pos_x_dif, 0, nhits_dif);
    bnk::put<double>("pos_y_dif", pos_y_dif, 0, nhits_dif);
    bnk::put<double>("pos_z_dif", pos_z_dif, 0, nhits_dif);

    // bnk::put<int>("nhits_raw", nhits_raw);
    // bnk::put<int>("material_raw", material_raw, 0, nhits_raw);
    // bnk::put<int>("detid_raw", detid_raw, 0, nhits_raw);
    // bnk::put<int>("strip_x_raw", strip_x_raw, 0, nhits_raw);
    // bnk::put<int>("strip_y_raw", strip_y_raw, 0, nhits_raw);
    // bnk::put<double>("edep_raw", edep_raw, 0, nhits_raw);
    // bnk::put<double>("pos_x_raw", pos_x_raw, 0, nhits_raw);
    // bnk::put<double>("pos_y_raw", pos_y_raw, 0, nhits_raw);
    // bnk::put<double>("pos_z_raw", pos_z_raw, 0, nhits_raw);
    
    return anl::ANL_OK;
}

int DiffuseEnergyCharge::FillDiffusedEnergy
(detector_stack& det, const hit& h)
//(TH2D* detector_pixel, const hit& h)
{
    auto sigma = this->DiffusionSigmaAnode(h.pos_z, h.pixel_center_z);
    
    static constexpr int diffusion_number = 100;
    static constexpr double dif_factor = (double)1/diffusion_number;
    double edep_div = h.edep*dif_factor;

    static constexpr double twopi = 2 * 3.1415926535;
    
    for ( int i=0; i<diffusion_number; ++i ) {
	auto radius = gRandom->Gaus(0.0, sigma);
	auto theta = gRandom->Uniform(0.0, twopi);
	auto dx = radius * std::cos(theta);
	auto dy = radius * std::sin(theta);
	// detector_pixel->Fill( h.pos_x+dx, h.pos_y+dy, edep_div );

	det.detectors[h.detid]->AddContent( h.pos_x+dx, h.pos_y+dy, edep_div );
    }
    
    return 0;
}

int DiffuseEnergyCharge::mod_endrun()
{
    /** This function is called at the end of the run **/
    cout << mod_name2() << "::mod_endrun()";
    cout << " -> Good Bye. :)" << endl;

    /** Example of operations described here **/

    /** Closing files **/
    // ifs.close(); // std::ifstream

    return anl::ANL_OK;
}

double DiffuseEnergyCharge::DiffusionSigmaAnode(double z, double pixel_center_z)
{
    static constexpr double eplus = 1.0;
    static constexpr double MeV = 1.0;
    static constexpr double kelvin = 1.0;
    static constexpr double k_Boltzmann = 8.617343e-11 * MeV/kelvin;
    static constexpr double STP_Temperature = 273.15*kelvin;
    
    double sigma = 0.;
    if ( parameter.diffusion_mode==0 ) {
	;
    }
    else if ( parameter.diffusion_mode==1 ) {
	const double KTOverQe
	    = ( k_Boltzmann * (parameter.temperature+STP_Temperature) ) / eplus;
	
	double zAnode = pixel_center_z + parameter.thickness*0.5;
	// if ( parameter.is_upsize_anode() )
	//     zAnode = pixel_center_z + parameter.thickness*0.5;
	double mut = this->Mutau(zAnode, z);
	sigma = std::sqrt(2.0 * KTOverQe * mut) * parameter.spread_factor_anode;
    }
    // else if (DiffusionMode()==2) {
    // 	sigma = DiffusionSigmaConstantAnode();
    // }    
    return sigma;
}

double DiffuseEnergyCharge::Mutau(double z, double z_initial)
{
    double muT = 0.0;
    if ( parameter.efield_mode==parameter_list::constant ) {
	muT = std::fabs( (z-z_initial)/parameter.efield_mean );
    }
    else if ( parameter.efield_mode==parameter_list::linear ) {
	const double alpha = parameter.efield_alpha;
	muT = std::fabs( alpha*std::log( (z+alpha)/(z_initial+alpha) )
		   / parameter.efield_mean );
    }
    // else if (EFieldMode()==FieldShape::Bending) {
    // 	if (zInitial <= z) {
    // 	    if (bendingPoint_ <= zInitial) {
    // 		muT = abs(alpha2_*log((z-bendingPoint_+alpha2_)/(zInitial-bendingPoint_+alpha2_)))/EFieldMax_;
    // 	    }
    // 	    else {
    // 		if (z <= bendingPoint_) {
    // 		    muT = abs(alpha1_*log((z-bendingPoint_+alpha1_)/(zInitial-bendingPoint_+alpha1_)))/EFieldMax_;
    // 		}
    // 		else {
    // 		    muT = (abs(alpha1_*log(alpha1_/(zInitial-bendingPoint_+alpha1_))) + abs(alpha2_*log((z-bendingPoint_+alpha2_)/alpha2_)))/EFieldMax_;
    // 		}
    // 	    }
    // 	}
    // 	else {
    // 	    if (bendingPoint_ >= zInitial) {
    // 		muT = abs(alpha1_*log((z-bendingPoint_+alpha1_)/(zInitial-bendingPoint_+alpha1_)))/EFieldMax_;
    // 	    }
    // 	    else {
    // 		if (z >= bendingPoint_) {
    // 		    muT = abs(alpha2_*log((z-bendingPoint_+alpha2_)/(zInitial-bendingPoint_+alpha2_)))/EFieldMax_;
    // 		}
    // 		else {
    // 		    muT = (abs(alpha2_*log(alpha2_/(zInitial-bendingPoint_+alpha2_))) + abs(alpha1_*log((z-bendingPoint_+alpha1_)/alpha1_)))/EFieldMax_;
    // 		}
    // 	    }
    // 	}
    // }
    
    return muT;
    
}
