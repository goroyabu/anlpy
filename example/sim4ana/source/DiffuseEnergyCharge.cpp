/**
   @file   DiffuseEnergyCharge.cpp
   @date   2020/08/24
   @author 
   @detail Automatically generated by make_anlpy_project.sh 1.0.0
**/

#include "DiffuseEnergyCharge.hpp"

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;

#include <bnk.hpp>
#include <evs.hpp>

namespace bnk
{
    template<typename T> int define
    (const std::string& key, const int size, const std::string& sizeref)
    {
        auto result = define<T>( key, size );
        if ( result!=0 ) return result;
        return setkeytosize<T>( key, sizeref );
    }
}

DiffuseEnergyCharge::DiffuseEnergyCharge()
    : anl::VANL_Module("DiffuseEnergyCharge", "0.1")
{
    define_parameter<int>("diffusion_mode", 1);
    define_parameter<std::string>("efield_mode", "linear");
    
    define_parameter<double>("temperature", -20);
    // define_parameter<double>("thickness", 0.500);
    define_parameter<double>("thickness_of_si",   0.500);
    define_parameter<double>("thickness_of_cdte", 0.750);
    define_parameter<double>("spread_factor_anode", 1.0);    
    define_parameter<double>("bias_voltage", 250.0);

    define_parameter<double>("charge_factor_max", 1.00);
    define_parameter<double>("charge_factor_min", 0.75);
    define_parameter<int>("use_hole_collect_factor_cdte", 1);
    
    // detector_pixel_dif
    // 	= new TH2D( "detector", "detector", 128, -16, 16, 128, -16, 16);
    // detector_pixels.SetAxis(128, -16, 16, 128, -16, 16);

    // bnk::define<int>( "DSDinfo_nstrips_x" );
    // bnk::define<int>( "DSDinfo_nstrips_y" );
    // bnk::define<double>( "DSDinfo_xmin" );
    // bnk::define<double>( "DSDinfo_xmax" );
    // bnk::define<double>( "DSDinfo_ymin" );
    // bnk::define<double>( "DSDinfo_ymax" );

    // bnk::put<int>( "DSDinfo_nstrips_x", 128 );
    // bnk::put<int>( "DSDinfo_nstrips_y", 128 );
    // bnk::put<double>( "DSDinfo_xmin", -16 );
    // bnk::put<double>( "DSDinfo_xmax", 16 );
    // bnk::put<double>( "DSDinfo_ymin", -16 );
    // bnk::put<double>( "DSDinfo_ymax", 16 );

    // this->nbinsx = bnk::get<int>( "DSDinfo_nstrips_x" );
    // this->nbinsy = bnk::get<int>( "DSDinfo_nstrips_y" );
    // this->xmin = bnk::get<double>( "DSDinfo_xmin" );
    // this->xmax = bnk::get<double>( "DSDinfo_xmax" );
    // this->ymin = bnk::get<double>( "DSDinfo_ymin" );
    // this->ymax = bnk::get<double>( "DSDinfo_ymax" );
    // detector_pixels.SetAxis(this->nbinsx, this->xmin, this->xmax, this->nbinsy, this->ymin, this->ymax);
}
DiffuseEnergyCharge::~DiffuseEnergyCharge()
{
}

int DiffuseEnergyCharge::mod_bgnrun()
{    
    constexpr static int npixels = 1000;
    bnk::define<int>( "nhits_dif" );
    bnk::define<int>( "detid_dif", npixels, "nhits_dif" );
    bnk::define<int>( "material_dif", npixels, "nhits_dif" );
    bnk::define<int>( "flag_dif", npixels, "nhits_dif" );
    bnk::define<int>( "strip_x_dif", npixels, "nhits_dif" );
    bnk::define<int>( "strip_y_dif", npixels, "nhits_dif" );
    bnk::define<double>( "edep_dif", npixels, "nhits_dif" );
    bnk::define<double>( "pos_x_dif", npixels, "nhits_dif" );
    bnk::define<double>( "pos_y_dif", npixels, "nhits_dif" );
    bnk::define<double>( "pos_z_dif", npixels, "nhits_dif" );

    bnk::define<int>( "nhits_x_str" );
    bnk::define<int>( "detid_x_str", npixels, "nhits_x_str" );
    bnk::define<int>( "material_x_str", npixels, "nhits_x_str" );
    bnk::define<int>( "flag_x_str", npixels, "nhits_x_str" );
    bnk::define<int>( "strip_x_str", npixels, "nhits_x_str" );
    bnk::define<double>( "edep_x_str", npixels, "nhits_x_str" );
    bnk::define<double>( "pos_x_str", npixels, "nhits_x_str" );

    bnk::define<int>( "nhits_y_str" );
    bnk::define<int>( "detid_y_str", npixels, "nhits_y_str" );
    bnk::define<int>( "material_y_str", npixels, "nhits_y_str" );
    bnk::define<int>( "flag_y_str", npixels, "nhits_y_str" );
    bnk::define<int>( "strip_y_str", npixels, "nhits_y_str" );
    bnk::define<double>( "edep_y_str", npixels, "nhits_y_str" );
    bnk::define<double>( "pos_y_str", npixels, "nhits_y_str" );
    
    parameter.diffusion_mode = get_parameter<int>("diffusion_mode");
    parameter.temperature = get_parameter<double>("temperature");
    // parameter.thickness = get_parameter<double>("thickness");
    parameter.thickness_of_si = get_parameter<double>("thickness_of_si");
    parameter.thickness_of_cdte = get_parameter<double>("thickness_of_cdte");

    parameter.bias_voltage = get_parameter<double>("bias_voltage");
    // parameter.efield_mean = parameter.bias_voltage/parameter.thickness;
    parameter.efield_mean_of_si = parameter.bias_voltage/parameter.thickness_of_si;
    parameter.efield_mean_of_cdte = parameter.bias_voltage/parameter.thickness_of_cdte;

    cout << "Efield_mean of Si   = " << parameter.efield_mean_of_si << " V/mm" << endl;
    cout << "Efield_mean of CdTe = " << parameter.efield_mean_of_si << " V/mm" << endl;
    
    auto efmode = get_parameter<std::string>("efield_mode");
    if ( efmode=="linear" )
	parameter.efield_mode = parameter_list::linear;
    else if ( efmode=="constant" )
	parameter.efield_mode = parameter_list::constant;

    parameter.spread_factor_anode = get_parameter<double>("spread_factor_anode");

    parameter.charge_factor_max = get_parameter<double>("charge_factor_max");
    parameter.charge_factor_min = get_parameter<double>("charge_factor_min");
    parameter.is_enabled_cce_cdte_xside
	= get_parameter<int>("use_hole_collect_factor_cdte");    

    this->nbinsx = bnk::get<int>( "DSDinfo_nstrips_x" );
    this->nbinsy = bnk::get<int>( "DSDinfo_nstrips_y" );
    this->xmin = bnk::get<double>( "DSDinfo_xmin" );
    this->xmax = bnk::get<double>( "DSDinfo_xmax" );
    this->ymin = bnk::get<double>( "DSDinfo_ymin" );
    this->ymax = bnk::get<double>( "DSDinfo_ymax" );
    detector_pixels.SetAxis(this->nbinsx, this->xmin, this->xmax, this->nbinsy, this->ymin, this->ymax);
    
    this->nstrips_x = bnk::get<int>( "DSDinfo_nstrips_x" );
    this->nstrips_y = bnk::get<int>( "DSDinfo_nstrips_y" );
    this->xaxis_min = bnk::get<double>( "DSDinfo_xmin" );
    this->xaxis_max = bnk::get<double>( "DSDinfo_xmax" );
    this->yaxis_min = bnk::get<double>( "DSDinfo_ymin" );
    this->yaxis_max = bnk::get<double>( "DSDinfo_ymax" );
    this->strip_pitch_x = ( xaxis_max-xaxis_min ) / nstrips_x;
    this->strip_pitch_y = ( yaxis_max-yaxis_min ) / nstrips_y;

    cout << "Xaxis = " << this->nstrips_x << " from ";
    cout << this->xaxis_min << " to " << this->xaxis_max;
    cout << " with " << this->strip_pitch_x << " pitch" << endl;
    cout << "Yaxis = " << this->nstrips_y << " from ";
    cout << this->yaxis_min << " to " << this->yaxis_max;
    cout << " with " << this->strip_pitch_y << " pitch" << endl;
    
    return anl::ANL_OK;
}

int DiffuseEnergyCharge::mod_ana()
{
    auto nhits_raw = bnk::get<int>("nhits_raw");
    auto detid_raw = bnk::getv<int>("detid_raw");
    auto material_raw = bnk::getv<int>("material_raw");
    auto strip_x_raw = bnk::getv<int>("strip_x_raw");
    auto strip_y_raw = bnk::getv<int>("strip_y_raw");
    auto edep_raw = bnk::getv<double>("edep_raw");
    auto pos_x_raw = bnk::getv<double>("pos_x_raw");
    auto pos_y_raw = bnk::getv<double>("pos_y_raw");
    auto pos_z_raw = bnk::getv<double>("pos_z_raw");
    auto dir_x_raw = bnk::getv<double>("dir_x_raw");
    auto dir_y_raw = bnk::getv<double>("dir_y_raw");
    auto dir_z_raw = bnk::getv<double>("dir_z_raw");
    auto pixel_center_x_raw = bnk::getv<double>("pixel_center_x_raw");
    auto pixel_center_y_raw = bnk::getv<double>("pixel_center_y_raw");
    auto pixel_center_z_raw = bnk::getv<double>("pixel_center_z_raw");
    
    // int nhits_dif = nhits_raw;
    std::vector<int> material_dif;//  = material_raw;
    std::vector<int> detid_dif;//    = detid_raw;
    // std::vector<int> strip_x_dif  = strip_x_raw;
    // std::vector<int> strip_y_dif  = strip_y_raw;
    std::vector<double> edep_dif;//  = edep_raw;
    std::vector<double> pos_x_dif;// = pos_x_raw;
    std::vector<double> pos_y_dif;// = pos_y_raw;
    std::vector<double> pos_z_dif;// = pos_z_raw;
    std::vector<double> pixel_center_z_dif;// = pixel_center_z_raw; 
    // auto strip_x_dif = convert_stripid_x(nhits_raw, detid_dif, pos_x_dif);
    // auto strip_y_dif = convert_stripid_y(nhits_raw, detid_dif, pos_y_dif);    
    std::vector<int> strip_x_dif;
    std::vector<int> strip_y_dif;
    
    int nhits_dif = 0;
    for ( int ihit=0; ihit<nhits_raw; ++ihit ) {
	if ( edep_raw[ihit]<=0 || 100000<edep_raw[ihit] )
	    continue;
	if ( detid_raw[ihit]<0 || 10000<detid_raw[ihit]  )
	    continue;
	if ( material_raw[ihit]<0 || 10000<material_raw[ihit] )
	    continue;
	if ( strip_x_raw[ihit]<0 || 10000<strip_x_raw[ihit] )
	    continue;
	if ( strip_y_raw[ihit]<0 || 10000<strip_y_raw[ihit] )
	    continue;

	material_dif.emplace_back( material_raw[ihit] );
	detid_dif.emplace_back   ( detid_raw[ihit]    );
	edep_dif.emplace_back    ( edep_raw[ihit]     );
	pos_x_dif.emplace_back   ( pos_x_raw[ihit]    );
	pos_y_dif.emplace_back   ( pos_y_raw[ihit]    );
	pos_z_dif.emplace_back   ( pos_z_raw[ihit]    );
	strip_x_dif.emplace_back ( strip_x_raw[ihit]  );
	strip_y_dif.emplace_back ( strip_y_raw[ihit]  );
	
	pixel_center_z_dif.emplace_back( pixel_center_z_raw[ihit] );	
	++nhits_dif;
    }

    // auto strip_x_dif = convert_stripid_x(nhits_dif, detid_dif, pos_x_dif);
    // auto strip_y_dif = convert_stripid_y(nhits_dif, detid_dif, pos_y_dif);    
    // for ( auto str : strip_y_raw )
    // 	strip_y_dif.emplace_back( str );    
    
    // if ( nhits_dif>0 ) {
    // 	cout << detid_dif[0] << endl;
    // 	cout << strip_x_dif[0] << "," << strip_y_dif[0] << endl;
    // 	cout << strip_x_raw[0] << "," << strip_y_raw[0] << endl;
    // }
    // strip_x_dif = strip_x_raw;
    // strip_y_dif = strip_y_raw;
    
    // detector_pixels.Reset();
    
    // for ( int ihit=0; ihit<nhits_raw; ++ihit ) {	
    // 	hit h;
    // 	h.material = material_raw[ihit];
    // 	h.detid    = detid_raw[ihit];
    // 	h.edep     = edep_raw[ihit];
    // 	h.pos_x    = pos_x_raw[ihit];
    // 	h.pos_y    = pos_y_raw[ihit];
    // 	h.pos_z    = pos_z_raw[ihit];
    // 	h.pixel_center_z = pixel_center_z_raw[ihit];

    // 	if ( detector_pixels.Exist(h.detid)==false ) {
    // 	    // detector_pixels.AddDetector(h.detid, h.material, h.pos_z);
    // 	    detector_pixels.AddDetector( h );
    // 	}

    // 	detector_pixels.detectors[h.detid]->nhits += 1;
    // 	this->FillDiffusedEnergy(detector_pixels, h);
    // }
    
    // int nhits_dif = 0;
    // std::vector<int> material_dif;
    // std::vector<int> detid_dif;
    // std::vector<int> strip_x_dif;
    // std::vector<int> strip_y_dif;
    // std::vector<double> edep_dif;
    // std::vector<double> pos_x_dif;
    // std::vector<double> pos_y_dif;
    // std::vector<double> pos_z_dif;
    // std::vector<double> pixel_center_z_dif;

    // for ( auto [ detid, detector ] : detector_pixels.detectors ) {

    // 	if ( detector->nhits==0 ) continue;

    // 	for ( auto [ pixel, edep ] : detector->content ) {
	
    // 	    auto [ xbin, ybin ] = detector->GetBinXYZ( pixel );
    // 	    if ( detector->IsBinInRange(xbin, ybin)==false ) continue;
	    
    // 	    if ( edep==0.0 ) continue;
	    
    // 	    edep_dif.emplace_back( edep );
    // 	    detid_dif.emplace_back( detid );
	    
    // 	    auto material = detector->material;
    // 	    material_dif.emplace_back( material );
	    
    // 	    strip_x_dif.emplace_back( xbin );
    // 	    strip_y_dif.emplace_back( ybin );
	    
    // 	    auto pos_x = detector->histo->GetXaxis()->GetBinCenter(xbin);
    // 	    auto pos_y = detector->histo->GetYaxis()->GetBinCenter(ybin);	    
    // 	    pos_x_dif.emplace_back( pos_x );
    // 	    pos_y_dif.emplace_back( pos_y );

    // 	    auto pos_z = detector->pos_z;
    // 	    pos_z_dif.emplace_back( pos_z );

    // 	    auto pix_z = detector->pixel_center_z;
    // 	    pixel_center_z_dif.emplace_back( pix_z );
	    
    // 	    ++nhits_dif;
    // 	}
	
    // }
    
    bnk::put<int>("nhits_dif", nhits_dif);
    bnk::put<int>("material_dif", material_dif, 0, nhits_dif);
    bnk::put<int>("detid_dif", detid_dif, 0, nhits_dif);
    bnk::put<int>("strip_x_dif", strip_x_dif, 0, nhits_dif);
    bnk::put<int>("strip_y_dif", strip_y_dif, 0, nhits_dif);
    bnk::put<double>("edep_dif", edep_dif, 0, nhits_dif);
    bnk::put<double>("pos_x_dif", pos_x_dif, 0, nhits_dif);
    bnk::put<double>("pos_y_dif", pos_y_dif, 0, nhits_dif);
    bnk::put<double>("pos_z_dif", pos_z_dif, 0, nhits_dif);
    
    std::vector<strip_data> data_x;
    std::vector<strip_data> data_y;
    for ( int index=0; index<nhits_dif; ++index ) {
        // auto p = std::make_pair( detid_dif[index], strip_x_dif[index] );
	auto p = std::make_pair( detid_dif[index], strip_x_dif[index] );
        strip_data new_strip;
        new_strip.det_strip_id = p;
        new_strip.material = material_dif[index];
        new_strip.edep = edep_dif[index];
        new_strip.pos = pos_x_dif[index];
	new_strip.z = pos_z_dif[index];
	new_strip.pixel_center_z = pixel_center_z_dif[index];
	new_strip.merge_same_strip(data_x);
    }
    for ( int index=0; index<nhits_dif; ++index ) {
        auto p = std::make_pair( detid_dif[index], strip_y_dif[index] );
        strip_data new_strip;
        new_strip.det_strip_id = p;
        new_strip.material = material_dif[index];
        new_strip.edep = edep_dif[index];
        new_strip.pos = pos_y_dif[index];
	new_strip.z = pos_z_dif[index];
	new_strip.pixel_center_z = pixel_center_z_dif[index];	
        new_strip.merge_same_strip(data_y);
    }

    // static const int detid_max = 5;//0;
    
    int nhits_x_out = 0;
    std::vector<int> detid_x_out;
    std::vector<int> material_x_out;
    std::vector<int> flag_x_out;
    std::vector<int> strip_x_out;
    std::vector<double> edep_x_out;
    std::vector<double> pos_x_out;
    int nhits_y_out = 0;
    std::vector<int> detid_y_out;
    std::vector<int> material_y_out;
    std::vector<int> flag_y_out;
    std::vector<int> strip_y_out;
    std::vector<double> edep_y_out;
    std::vector<double> pos_y_out;
    
    //for ( int detid=0; detid<detid_max; ++detid ) {
    int ndata_x = data_x.size();
    for ( int index=0; index<ndata_x; ++index ) {
	// for ( int stripid=1; stripid<=this->NstripX(); ++stripid ) {
	// auto index = strip_data::index_in(data_x, detid, stripid);
	auto [ detid, stripid ] = data_x[index].det_strip_id;
	if ( index<0 ) {
	    continue;
	    // if ( is_enabled_add_pedestal==false ) continue;
	    // edep_x_out.emplace_back( this->Pedestal() );
	    // flag_x_out.emplace_back( 1 );
	}
	else {
	    auto factor = ChargeCollectionFactorX( data_x[index] );
	    auto e_collected = data_x[index].edep * factor;
	    edep_x_out.emplace_back( e_collected );		
	    // edep_x_out.emplace_back( data_x[index].edep );
	    flag_x_out.emplace_back( 0 );
	}
	++nhits_x_out;
	detid_x_out.emplace_back( detid );
	material_x_out.emplace_back( data_x[index].material );
	strip_x_out.emplace_back( stripid );
	// pos_x_out.emplace_back( this->Xposition(stripid) );
	pos_x_out.emplace_back( data_x[index].pos );
    }
    //}

    //for ( int detid=0; detid<detid_max; ++detid ) {
    for ( int index=0; index<data_y.size(); ++index ) {	
	    // for ( int stripid=1; stripid<=this->NstripY(); ++stripid ) {
            // auto index = strip_data::index_in(data_y, detid, stripid);
	auto [ detid, stripid ] = data_y[index].det_strip_id;
	if ( index<0 ) {
	    continue;
	    // if ( is_enabled_add_pedestal==false ) continue;
	    // edep_y_out.emplace_back( this->Pedestal() );
	    // flag_y_out.emplace_back( 1 );
	}
	else {
	    auto factor = ChargeCollectionFactorY( data_y[index] );
	    auto e_collected = data_y[index].edep * factor;
	    edep_y_out.emplace_back( e_collected );				
	    // edep_y_out.emplace_back( data_y[index].edep );
	    flag_y_out.emplace_back( 0 );
	}
	++nhits_y_out;
	detid_y_out.emplace_back( detid );
	material_y_out.emplace_back( data_y[index].material );
	strip_y_out.emplace_back( stripid );
	// pos_y_out.emplace_back( this->Yposition(stripid) );
	pos_y_out.emplace_back( data_y[index].pos );
    }
    // }
    


    
    // for ( int detid=0; detid<detid_max; ++detid ) {
    // 	for ( int index=0; index<data_x.size(); ++index ) {
    // 	    // for ( int stripid=1; stripid<=this->NstripX(); ++stripid ) {
    //         // auto index = strip_data::index_in(data_x, detid, stripid);
    //         if ( index<0 ) {
    // 		continue;
    //             // if ( is_enabled_add_pedestal==false ) continue;
    //             // edep_x_out.emplace_back( this->Pedestal() );
    //             // flag_x_out.emplace_back( 1 );
    //         }
    //         else {
    // 		auto factor = ChargeCollectionFactorX( data_x[index] );
    // 		auto e_collected = data_x[index].edep * factor;
    // 		edep_x_out.emplace_back( e_collected );		
    //             // edep_x_out.emplace_back( data_x[index].edep );
    //             flag_x_out.emplace_back( 0 );
    //         }
    //         ++nhits_x_out;
    //         detid_x_out.emplace_back( detid );
    //         material_x_out.emplace_back( data_x[index].material );
    //         strip_x_out.emplace_back( stripid );
    //         // pos_x_out.emplace_back( this->Xposition(stripid) );
    // 	    pos_x_out.emplace_back( data_x[index].pos );
    //     }
    // }
    // for ( int detid=0; detid<detid_max; ++detid ) {
    // 	for ( int index=0; index<data_y.size(); ++index ) {
    // 	    // for ( int stripid=1; stripid<=this->NstripY(); ++stripid ) {
    //         // auto index = strip_data::index_in(data_y, detid, stripid);
    //         if ( index<0 ) {
    // 		continue;
    //             // if ( is_enabled_add_pedestal==false ) continue;
    //             // edep_y_out.emplace_back( this->Pedestal() );
    //             // flag_y_out.emplace_back( 1 );
    //         }
    //         else {
    // 		auto factor = ChargeCollectionFactorY( data_y[index] );
    // 		auto e_collected = data_y[index].edep * factor;
    // 		edep_y_out.emplace_back( e_collected );				
    //             // edep_y_out.emplace_back( data_y[index].edep );
    //             flag_y_out.emplace_back( 0 );
    //         }
    //         ++nhits_y_out;
    //         detid_y_out.emplace_back( detid );
    //         material_y_out.emplace_back( data_y[index].material );
    //         strip_y_out.emplace_back( stripid );
    //         // pos_y_out.emplace_back( this->Yposition(stripid) );
    // 	    pos_y_out.emplace_back( data_y[index].pos );
    //     }
    // }
    
    bnk::put<int>   ( "nhits_x_str",    nhits_x_out );
    bnk::put<int>   ( "detid_x_str",    detid_x_out,    0, nhits_x_out );
    bnk::put<int>   ( "material_x_str", material_x_out, 0, nhits_x_out );
    bnk::put<int>   ( "flag_x_str",     flag_x_out,     0, nhits_x_out );
    bnk::put<int>   ( "strip_x_str",    strip_x_out,    0, nhits_x_out );
    bnk::put<double>( "edep_x_str",     edep_x_out,     0, nhits_x_out );
    bnk::put<double>( "pos_x_str",      pos_x_out,      0, nhits_x_out );

    bnk::put<int>   ( "nhits_y_str",    nhits_y_out );
    bnk::put<int>   ( "detid_y_str",    detid_y_out,    0, nhits_y_out );
    bnk::put<int>   ( "material_y_str", material_y_out, 0, nhits_y_out );
    bnk::put<int>   ( "flag_y_str",     flag_y_out,     0, nhits_y_out );
    bnk::put<int>   ( "strip_y_str",    strip_y_out,    0, nhits_y_out );
    bnk::put<double>( "edep_y_str",     edep_y_out,     0, nhits_y_out );
    bnk::put<double>( "pos_y_str",      pos_y_out,      0, nhits_y_out );

    // cout << "nhits=" << nhits_x_out << "," << nhits_y_out << endl;
    // bnk::put<int>("nhits_raw", nhits_raw);
    // bnk::put<int>("material_raw", material_raw, 0, nhits_raw);
    // bnk::put<int>("detid_raw", detid_raw, 0, nhits_raw);
    // bnk::put<int>("strip_x_raw", strip_x_raw, 0, nhits_raw);
    // bnk::put<int>("strip_y_raw", strip_y_raw, 0, nhits_raw);
    // bnk::put<double>("edep_raw", edep_raw, 0, nhits_raw);
    // bnk::put<double>("pos_x_raw", pos_x_raw, 0, nhits_raw);
    // bnk::put<double>("pos_y_raw", pos_y_raw, 0, nhits_raw);
    // bnk::put<double>("pos_z_raw", pos_z_raw, 0, nhits_raw);
    
    return anl::ANL_OK;
}

int DiffuseEnergyCharge::FillDiffusedEnergy
(detector_stack& det, const hit& h)
{
    auto sigma = this->DiffusionSigmaAnode(h.pos_z, h.pixel_center_z, h.material);
    // cout << sigma << endl;
    
    static constexpr int diffusion_number = 100;
    static constexpr double dif_factor = (double)1/diffusion_number;
    double edep_div = h.edep*dif_factor;

    static constexpr double twopi = 2 * 3.1415926535;
    
    for ( int i=0; i<diffusion_number; ++i ) {
	auto radius = gRandom->Gaus(0.0, sigma);
	auto theta = gRandom->Uniform(0.0, twopi);
	auto dx = radius * std::cos(theta);
	auto dy = radius * std::sin(theta);

	det.detectors[h.detid]->AddContent( h.pos_x+dx, h.pos_y+dy, edep_div );
    }
    
    return 0;
}

int DiffuseEnergyCharge::mod_endrun()
{
    /** This function is called at the end of the run **/
    cout << mod_name2() << "::mod_endrun()";
    cout << " -> Good Bye. :)" << endl;

    /** Example of operations described here **/

    /** Closing files **/
    // ifs.close(); // std::ifstream

    return anl::ANL_OK;
}

double DiffuseEnergyCharge::DiffusionSigmaAnode
(double z, double pixel_center_z, int material)
{
    static constexpr double eplus = 1.0;
    static constexpr double MeV = 1.0;
    static constexpr double kelvin = 1.0;
    static constexpr double k_Boltzmann = 8.617343e-11 * MeV/kelvin;
    static constexpr double STP_Temperature = 273.15*kelvin;
    
    double sigma = 0.;
    if ( parameter.diffusion_mode==0 ) return sigma;	
    
    else if ( parameter.diffusion_mode==1 ) {

	const double KTOverQe
	    = ( k_Boltzmann * (parameter.temperature+STP_Temperature) ) / eplus;
	
	double zAnode = pixel_center_z;
	if ( material==0 )
	    zAnode += parameter.thickness_of_si*0.5;
	else if ( material==1 )
	    zAnode += parameter.thickness_of_cdte*0.5;
	
	// if ( parameter.is_upsize_anode() )
	//     zAnode -= parameter.thickness*0.5;

	double mut = this->Mutau(zAnode, z, material);
	sigma = std::sqrt(2.0 * KTOverQe * mut) * parameter.spread_factor_anode;
    }
    // else if (DiffusionMode()==2) {
    // 	sigma = DiffusionSigmaConstantAnode();
    // }    
    return sigma;
}

double DiffuseEnergyCharge::Mutau(double z, double z_initial, int material)
{
    double muT = 0.0;
    double efield_mean = parameter.efield_mean_of_cdte;
    if ( material==0 ) efield_mean = parameter.efield_mean_of_si;
    else if ( material==1 ) efield_mean = parameter.efield_mean_of_cdte;
	
    if ( parameter.efield_mode==parameter_list::constant ) {
	muT = std::fabs( (z-z_initial)/efield_mean );
    }
    else if ( parameter.efield_mode==parameter_list::linear ) {
	const double alpha = parameter.efield_alpha;
	muT = std::fabs( alpha*std::log( (z+alpha)/(z_initial+alpha) )
			 / efield_mean );
    }
    // else if (EFieldMode()==FieldShape::Bending) {
    // 	if (zInitial <= z) {
    // 	    if (bendingPoint_ <= zInitial) {
    // 		muT = abs(alpha2_*log((z-bendingPoint_+alpha2_)/(zInitial-bendingPoint_+alpha2_)))/EFieldMax_;
    // 	    }
    // 	    else {
    // 		if (z <= bendingPoint_) {
    // 		    muT = abs(alpha1_*log((z-bendingPoint_+alpha1_)/(zInitial-bendingPoint_+alpha1_)))/EFieldMax_;
    // 		}
    // 		else {
    // 		    muT = (abs(alpha1_*log(alpha1_/(zInitial-bendingPoint_+alpha1_))) + abs(alpha2_*log((z-bendingPoint_+alpha2_)/alpha2_)))/EFieldMax_;
    // 		}
    // 	    }
    // 	}
    // 	else {
    // 	    if (bendingPoint_ >= zInitial) {
    // 		muT = abs(alpha1_*log((z-bendingPoint_+alpha1_)/(zInitial-bendingPoint_+alpha1_)))/EFieldMax_;
    // 	    }
    // 	    else {
    // 		if (z >= bendingPoint_) {
    // 		    muT = abs(alpha2_*log((z-bendingPoint_+alpha2_)/(zInitial-bendingPoint_+alpha2_)))/EFieldMax_;
    // 		}
    // 		else {
    // 		    muT = (abs(alpha2_*log(alpha2_/(zInitial-bendingPoint_+alpha2_))) + abs(alpha1_*log((z-bendingPoint_+alpha1_)/alpha1_)))/EFieldMax_;
    // 		}
    // 	    }
    // 	}
    // }
    
    return muT;
    
}
